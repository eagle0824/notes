1.//josn数组解析实例
   String string =  "{"
        + " \"id\":0,"
       + " \"cmd\": \"awl\","
        + " \"cnt\":[{\"list_number\":\"10086\",\"list_name\":\"name2\"},"
        + " {"+
        " \"list_number\":\"10000\",\"list_name\":\"name\" "+
                        "}]}";
      JSONObject jsonObject = (JSONObject) new JSONTokener(str).nextValue();
      JSONArray jsonArray = jsonObject.getJSONArray("cnt");






    public static void addWhiteList(Context context,String str){
        String strSTR = "[{\"list_number\":\"10086\",\"list_name\":\"name2\"},"
            + " {"+
            " \"list_number\":\"10000\",\"list_name\":\"name\" "+
                            "}]";
        Log.d(TAG,"STR:"+str);

            JSONArray jsonArray = new JSONArray(strSTR);
            Log.d(TAG,"jsonArray:"+jsonArray.length());
            for (int j=0; j<jsonArray.length();j++) {
                String address = (String) jsonArray.getJSONObject(j).get(
                        "list_number");
                Log.d(TAG, "number:" + address);

            }
   }

	[]	Array
	{}	Object


2.//判断当前是否时漫游,sim卡状态
TelephonyManager mPhone = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
mPhone.isNetworkRoaming();
其中isNetworkRoaming()方法为
import android.os.SystemProperties;
public boolean isNetworkRoaming() {
        return "true".equals(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING));
    }

3.//判断网络是否链接
private boolean isConnected() {
        ConnectivityManager mConnMgr = (ConnectivityManager)
                mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        return (mConnMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE_MMS).
                isConnected());
    }


//判断网络是否可以使用
	private boolean isNetworkAvailable(){

            ConnectivityManager connectivity = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            if (connectivity == null) {
                Log.e(TAG, "couldn't get connectivity manager");
            } else {
                NetworkInfo[] info = connectivity.getAllNetworkInfo();
                if (info != null) {
                    for (int i = 0; i < info.length; i++) {
                        if (info[i].getState() == NetworkInfo.State.CONNECTED) {
                            return true;
                        }
                    }
                }
            }
            Log.w(TAG, "network is not available");
            return false;
        }


通过ConnectivityManager获取NetworkInfo==（CM.getActiveNetworkInfo()）=networkInfo
networkInfo.getTypeName();//cmwap/cmnet/wifi/uniwap/uniet何种方式链接
networkInfo.getState()链接状态状CONNECTED
networkInfo.isConnected()
networkInfo.isRoaming()
netWorkInfo.isAvailable()
netWorkInfo.isConnectedOrConnecting()网络是否已经链接或链接中
newWorkInfo.isFailover()网络是否有问题

ConnectivityManager 通过Context.getSystemService(Context.CONNECTIVITY_SERVICE)获取
主要功能：
	（1）监控Wi-Fi, GPRS, UMTS, 等的链接
	（2）当网络链接改变的时候，发送广播
	（3）当一个网络链接失败时，尝试转移到另一个网络
	（4）提供api给应用，应用可以获取可用网络的状态
SUPL---Secure User Plane Location(安全用户面定位技术)用户定位
DUN---Dail up NetWorking(拨号网络架构)

manifest.xml中添加
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>


4.在资源文件中使用 <xliff:g id="app_name">%s</xliff:g>标签
	需要在String.xml中的<resources>标签中添加 xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2"
	for example
	<string name="speed_app_name">Speed greater than 20km/h, can not open <xliff:g id="app_name">%s</xliff:g></string>
	在应用程序中通过一下方法获取 String toastStr = this.getResources().getString(R.string.speed_app_name,”aaa”);
 	<string name="broadcast_from_to"><xliff:g id="sender" example="me">%1$s</xliff:g> to <xliff:g id="recipient" example="Megan">%2$s</xliff:g></string>
	getResources().getString(R.string.broadcast_from_to,"string1","string2");


5.监听数据库数据变化
boolean notifyForDescendents;表示是否监听子数据发生变化（如table中的某_id项变化）
ContentResolver.registerContentObserver(Uri uri, boolean notifyForDescendents,ContentObserver observer)

Activity.getContentResolver().registerContentObserver(
                Uri.parse(Phone.CONTENT_URI.toString() + "phoneNumberChange"), true,
                mContentObserver);

private ContentObserver mContentObserver = new ContentObserver(new Handler()) {

        @Override
        public boolean deliverSelfNotifications() {
            return super.deliverSelfNotifications();
        }

        @Override
        public void onChange(boolean selfChange) {
            super.onChange(selfChange);
           //when database change to do something!
        }

    };


6.android中的 audio and video
	MediaPalyer	------播放（res/raw下文件，sdcard或存储区域上文件，网络中的文件-可下载）
	MediaRecorder	------录音（需要硬件支持）
	通过路径引用res/raw下文件 Uri.parse("android.resource://"+ this.getPackageName() + "/" + R.raw.castor)
	(1)palying from a raw resource
		MediaPlayer mp = MediaPlayer.create(context, R.raw.sound_file_1);
        	mp.start();
		停止stop();暂停pause()
		再次播放：先调reset()和prepare()再调用start()
	（2）播放file或者stream
		MediaPlayer mp = new MediaPlayer();
    		mp.setDataSource(PATH_TO_FILE);
		mp.prepare();
		mp.start();
		停止stop();暂停pause()
		再次播放start()
	释放资源release()
	(3)播放JET内容JetPalyer 详见官方文档Dev Guide --->Audio and video
	(4)录音（MediaRecorder）详见官方文档Dev Guide --->Audio and video

7.获取电源状态锁
	PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
 	PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, "My Tag");
 	wl.acquire();
   	..screen will stay on during this section..//屏幕一直开
 	wl.release();

	newWakeLock(int int1,String str),int1有如下四个参数
	Flag Value 			CPU 	Screen 	Keyboard
	PARTIAL_WAKE_LOCK 		On* 	Off 		Off
	SCREEN_DIM_WAKE_LOCK 	On 	Dim 		Off
	SCREEN_BRIGHT_WAKE_LOCK 	On 	Bright 	Off
	FULL_WAKE_LOCK 		On 	Bright 	Bright


8.app install location（app安装位置设置）
	从api 8(即android2.2)开始，可以通过下面配置设置apk的安装位置
	<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    		android:installLocation="preferExternal"
    	... >
	android:installLocation有三个参数
	(1) internalOnly 缺省值：安装到内存中，若内存满以后，apk将不能安装
	(2) auto 首先安装的内存，若内存满，则安装到外部存储设备中（sdcard），一旦安装，可以通过系统设置移动应用程序
	(3) preferExternal 与auto相反，首先考虑外部存储（sdcard）若不可用或已满则装到内存中

9.应用程序的安装
	安装过程：复制APK安装包到system/app或data/app目录下，解压并扫描安装包，把dex文件（Dalvik字节码）保存到dalvik-cache目录下，并在data/data目录下创建对应的应用数据目录
	卸载过程：删除安装过程中在上述三个目录下创建的文件以及目录

	涉及的目录：
	(1)system/app		系统自带的应用程序，无法删除
	(2)data/app		用户程序安装的目录，有删除权，安装时，将APK文件复制到此目录
	(3)data/data		存放应用程序的数据
	(4)data/dalvik-cache	（dex文件时dalvik虚拟机的可执行文件，其大小约为原始apk文件大小的四分之一）

10.解决adb push 问题failed to copy 'framework.jar' to '/system/framework/framework.jar': Read-only file system
	adb remount//

	adb shell
	mount	//查看system属性r
	mount -o remount /dev/block/mtdblock0 /system
	mount	//查看system属性rw

	还原system只读属性
	mount -o remount,ro /system

	cat /sdcard/busybox > /system/xbin/busybox

11.判断运行在模拟器上
	"1".equals(SystemProperties.get("ro.kernel.qemu"))
	设备上，防止点不到最底下的按钮，ontouch事件，y点要偏移-10;即y的实际值为触点位置y+（-10）

12.公开系统id，或者资源
	（1）在build/frameworks/base/core/res/res/values/ids.xml
	添加定义，例如： <item type="id" name="inputExtractAction" />
	（2）在build/frameworks/base/core/res/res/values/public.xml
	添加公开资源id，例如： <public type="id" name="inputExtractAction" id="0x0102002d" />
	要注意，type值，id是依次累加的，
	（3）在build/frameworks/base/core/res/res目录下编译，执行命令mm
	编译出out/target/product/generic/system/framework/framework-res.apk
	（4）编译build/frameworks/base，编译，执行mm
	 编译出out/target/product/generic/system/framework/framework.jar

13.drawable-hdpi,drawable-mdpi,drawable-ldpi的区别
	（1）drawable-hdpi存放高分辨率图片	WVGA（480×800），FWVGA（480×854）
	（2）drawable-mdpi存放中等分辨率图片	HVGA(320*480)
	（3）drawable-ldpi存放低分辨率图片	QVGA(240*320)

14.xml文件解析

	 XmlResourceParser xrp = this.getApplicationContext().getResource().getXml(resourceId);
        try {
            int mXmlEventType = xrp.next();
            while (mXmlEventType != XmlResourceParser.END_DOCUMENT) {
                boolean mNextEventFetched = false;
                if (mXmlEventType == XmlResourceParser.START_TAG) {
                    String attribute = xrp.getName();
                    if (XMLTAG_SKB_TEMPLATE.compareTo(attribute) == 0) {
                        ......
 			 Drawable skbBg = getDrawable(xrp, XMLATTR_SKB_BG, null);//XMLATTR_SKB_BG 为着XMLTAG_SKB_TEMPLAT标签中的属性名
                    } else if (XMLTAG_KEYTYPE.compareTo(attribute) == 0) {
                        ......
                    } else if (XMLTAG_KEYICON.compareTo(attribute) == 0) {
                       ......
                    }
                }
                // Get the next tag.
                if (!mNextEventFetched) mXmlEventType = xrp.next();
            }
            xrp.close();
        } catch (XmlPullParserException e) {
            // Log.e(TAG, "Ill-formatted keyboard template resource file");
        } catch (IOException e) {
            // Log.e(TAG, "Unable to keyboard template resource file");
        }

	private Drawable getDrawable(XmlResourceParser xrp, String name,
            Drawable defValue) {
        int resId = xrp.getAttributeResourceValue(null, name, 0);
        if (0 == resId) return defValue;
        return mResources.getDrawable(resId);
    }


15.设置activity没有titile
	onCreate()中添加：requestWindowFeature(Window.FEATURE_NO_TITLE);
	自定义title标题布局
	onCreate()中，
	//Must be called before setContentView().
	requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
       setContentView(R.layout.image_gallery);//image_gallery.xml为自定义的标题格式
       getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE,
                R.layout.custom_gallery_title);
	注意：requestWindowFeature要在setContentView()之前调用

	自定义titlebar
	 requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
        setContentView(R.layout.custom_title);
        getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.custom_title_1);// R.layout.custom_title_1为自定义titlebar布局


16.自定义组件时，在xml中直接引用时，需要建立含有参数的构造函数例如
	public Switcher(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
	这样才可以在layout文件中，直接通过
	<com.archermind.facerecognize.Switcher
			android:id="@+id/mSwitch"
			android:layout_width="wrap_content"
			android:layout_height="wrap_content"
			android:src="@drawable/pic14"
			android:background="@drawable/pic13">
	</com.archermind.facerecognize.Switcher>
	引用！

17.在其他线程中访问UI线程
	1.Activity.runOnUiThread(Runnable)
	2.View.post(Runnable)
	3.View.postDelay(Runnable,time)
	4.Handler
	5.AsynTask<>

18.DDMS截图
	1.eclipse-->ddms-->devices-->screen capture(titlebar上的拍照图标)

19.设置开屏密码等系统权限
	1.receiver ---》DeviceAdminReceiver
	<receiver android:name=".app.DeviceAdminSample"
		android:label="@string/sample_device_admin"
		android:description="@string/sample_device_admin_description"
	       android:permission="android.permission.BIND_DEVICE_ADMIN">
		<meta-data android:name="android.app.device_admin"
			android:resource="@xml/device_admin_sample" />
		<intent-filter>
			<action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
		</intent-filter>
	</receiver>
	数据类型为：
	<device-admin xmlns:android="http://schemas.android.com/apk/res/android">
		<uses-policies>
		        <limit-password />
		        <watch-login />
		        <reset-password />
		        <force-lock />
		        <wipe-data />
		        <expire-password />
		        <encrypted-storage />
		</uses-policies>
	</device-admin>

	2.应用获得系统密码，锁屏等权限 DevicePolicyManager
	 	Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
                intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,
                        mDeviceAdminSample);//mDeviceAdminSample = new ComponentName(Controller.this, DeviceAdminSample.class);
                intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,
                        "Additional text explaining why this needs to be added.");
                startActivityForResult(intent, RESULT_ENABLE);

	3.设置pin密码
	Intent intent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);
       startActivity(intent);
	4.判断当前应用是否拥有激活权限
	DevicePolicyManager.isAdminActive(mDeviceAdminSample);
	5.强制lock	DevicePolicyManager.lockNow()
	6,在下次重启时擦除用户数据，不会擦除sd卡等数据	DevicePolicyManager.wipeData(0);
	擦除sd卡数据	DevicePolicyManager.wipeData(DevicePolicyManager.WIPE_EXTERNAL_STORAGE); \
	7.设置密码等级	DevicePolicyManager.setPasswordQuality(componentName,quality);
	quality 在DevicePolicyManager中有定义.for example : PASSWORD_QUALITY_UNSPECIFIED = 0;


20.从资源文件中读取drawable
	java.io.InputStream is = context.getResources().openRawResource(R.drawable.beach);
       BitmapFactory.Options opts = new BitmapFactory.Options();
       Bitmap mBitmap;
       opts.inJustDecodeBounds = true;
       mBitmap = BitmapFactory.decodeStream(is, null, opts);
	canvas.drawBitmap(mBitmap, 10, y, p);

	mDrawable = context.getResources().getDrawable(R.drawable.button);
       mDrawable.setBounds(150, 20, 300, 100);
	mDrawable.draw(canvas);

21.canvas.drawText("str",x,y,paint)关于x，y的解释
	str:要画的文字
	x:字左边的x坐标位置
	y：字四分之三处高度的位置，因此要从顶部绘制字的时候，y的取值应为字高度的是3/4

23.继承view的时候设置view的大小可以通过onMeasure方法
	 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int mOldWidth = mMeasuredWidth;
        int mOldHeight = mMeasuredHeight;
        Environment env = Environment.getInstance();
        int measuredWidth = env.getScreenWidth();
        int measuredHeight = Environment.CANDIDDTES_EXPAND_WINDOW_HEIGHT;
        widthMeasureSpec = MeasureSpec.makeMeasureSpec(measuredWidth, MeasureSpec.EXACTLY);//设置精确大小
        heightMeasureSpec = MeasureSpec.makeMeasureSpec(measuredHeight, MeasureSpec.EXACTLY);//设置精确大小
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),
                widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(),
                heightMeasureSpec));
        if (mOldWidth != mMeasuredWidth || mOldHeight != mMeasuredHeight) {
            onSizeChanged();
        }
    }
	在onSizeChanged中，可以重设view大小

24.通过设置EditText的属性为
	android:inputType="number"仅输入数字		具体控制在 TextView代码中控制
	android:inputType="phone"仅输入电话号码相关	 InputType.TYPE_CLASS_PHONE
	例如：数字------》DigitsKeyListener	位于frameworks/base/core/java/android/text/method/DigitsKeyListener.java中具体设置过滤字符的类型

	具体有一下几个关于类型的类的限制
	DateKeyListener	DateTimeKeyListener	DialerKeyListener(电话号码相关)	DigitsKeyListener	KeyListener	LinkMovementMethod
	MetaKeyKeyListener	MovementMethod	PasswordTransformationMethod	SingleLineTransformationMethod	TextKeyListener
	TimeKeyListener	TransformationMethod

25.安装apk-----adb install -r ***.apk
	会出现 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES的错误
	由于签名冲突造成的，比如用adb 的Debug权限签名，后来又用标准的sign签名，然后安装同一个文件，会出现此错误，
	必须先adb uninstall package(apk),然后再安装

26.反编译apk
	(1)工具 : dex2jar;JD-GUI
	(2)步骤
		a.首先找到android软件安装包中的classes.dex。把.apk文件改名为.zip，然后解压缩，得到其中的classes.dex文件，它就是java编译文件，再通过dx工具打包成的。
		b.把classes.dex拷贝到dex2jar.bat所在目录。在命令行模式下定位到dex2jar.bat所在的目录，运行dex2jar.bat classes.dex生成，(linux 运行 sh dex2jar.sh classes.dex)classes.dex.dex2jar.jar
		c.运行JD-GUI工具，打开上面的jar文件(命令行执行 ./jd-gui)

27.ubuntu切换用户
	sudo su		切换root用户
	su archermind		切换到"archemrind"用户


28.安装apk时，报insufficient permissions for device的错误
	sudo -s	切换root用户
	adb -d kill-server
	adb -d shell
	exit
	exit	退出root用户


29.vim 显示中文乱码
	sudo su
	vim /usr/share/vim/vimrc
	添加
	set fileencoding=utf-8,gb2312,gbk,gb18030
	set termencoding=utf-8
	set fileformats=unix
	set encoding=prc

30.Popupwindow的使用方法概要如下：
	PopupWindow window;
	View v = this.getLayoutInflater().inflate(R.layout.popupwindow, null);
	window = new PopupWindow(v, 200, 300);
       window.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
	window.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);//设置长宽并非必须，但是不设置可能会导致图片显示尺寸不合适。
       window.setOutsideTouchable(true);//不设置此项则下面的捕获window外touch事件就无法触发。
       Drawable win_bg = this.getResources().getDrawable(R.drawable.bg);
	window.setBackgroundDrawable(win_bg);
	这个很WS，即使在XML里设置了background也认为是没有背景，必须在这里指定背景，如果不指定同样无法触发下面的Touch监听事件。
       window.setTouchInterceptor(new OnTouchListener() {
	@Override
	public boolean onTouch(View v, MotionEvent event) {
	if (event.getAction() == MotionEvent.ACTION_OUTSIDE)
		window.dismiss();
		return false;
	}
	});
	在onCreate里设置好这些后，在某个button的onClick里调用window.showAsDropDown(v);即可（v是onClick函数的参数）

	如果CustomPopupWindow继承了PopupWindow，而QuickAction继承了CustomPopupWindow的话，在QuickAction里不要用setContentView，不然可能图片会变得很大，比实际尺寸还大，目前原因未明。
	QuickAction的XML文件，最外层的要用LinearLayout，不能用RelativeLayout，不然图片会很大，原因未明。

	用LinearLayout时会出现上面的元素覆盖下面的，比如上面一个listview下面一个button，listview的元素多到覆盖屏幕时就会覆盖掉button，可以把LinearLayout改成RealtiveLayout即可。


31.android 屏蔽程序自动弹出虚拟键盘
	通过设置AndroidManifest.xml文件里的activity属性
	android:windowSoftInputMode="stateAlwaysHidden"
	可禁止自动弹出~~
	AndroidManifest.xml里面对要修改的activity添加android:windowSoftInputMode="adjustPan"就可以实现输入法不挤压ui，还有其他取值，有需要去看api


32.横竖屏切换不重启activity

	可以给每个activity加上android:configChanges="keyboardHidden|orientation"属性,就不会重启activity.而是去调用onConfigurationChanged(Configuration newConfig). 这样就可以在这个方法里调整显示方式.比如
Java代码
if(newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE){
    //横向
    setContentView(R.layout.file_list_landscape);
}else{
    //竖向
    setContentView(R.layout.file_list);
}


33	横竖屏备忘


Android横竖屏要解决的问题应该就两个：一。布局问题；二。重新载入问题。

1.布局问题：如果不想让软件在横竖屏之间切换，最简单的办法就是在项目的 AndroidManifest.xml中找到你所指定的activity中加上android:screenOrientation属性，他有以下几个参数：

"unspecified"
默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向.
"landscape"
横屏显示（宽比高要长）
"portrait"
竖屏显示(高比宽要长)
"user"
用户当前首选的方向
"behind"
和该Activity下面的那个Activity的方向一致(在Activity堆栈中的)
"sensor"
有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。
"nosensor"
忽略物理感应器，这样就不会随着用户旋转设备而更改了 （ "unspecified"设置除外 ）。

也可以在Java代码中通过setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);来设置。

如果要让软件在横竖屏之间切换，由于横竖屏的高宽会发生转换，有可能会要求不同的布局。可以通过以下方法来切换布局：

1）在res目录下建立layout-land和layout-port目录,相应的layout文件不变，比如main.xml。layout-land是横屏的layout,layout-port是竖屏的layout，其他的不用管，模拟器会自动寻找。

2）通过this.getResources().getConfiguration().orientation来判断当前是横屏还是竖屏然后来加载相应的xml布局文件。因为当屏幕变为横屏的时候,系统会重新呼叫当前Activity的OnCreate方法,你可以把以下方法放在你的OnCreate中来检查当前的方向,然后可以让你的SetContentView来载入不同的Layout xml.
if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
Log.i("info", "landscape");
}
else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
Log.i("info", "portrait");
}

2.重新载入问题。如果不需要从新载入，可以在androidmanifest.xml中加入配置android:configChanges="orientation"，配置android:configChanges的作用就是如文档所说的：Specify one or more configuration changes that the activity will handle itself. If not specified, the activity will be restarted if any of these configuration changes happen in the system。这样在程序中. Activity就不会重复的调用onCreate()甚至不会调用onPause.onResume.只会调用一个onConfigurationChanged(Configuration newConfig)。

–*************其实在这里我遇到两个奇怪的问题，那就是

1.如果我在android:configChanges中只设置orientation，他依然会重新加载，只有设置了orientation|keyboardHidden它才会只调用一个onConfigurationChanged(Configuration newConfig)

2.当横屏变竖屏的时候，他会调用两次onConfigurationChanged，而竖屏转横屏时他只调用一次onConfigurationChanged，真是太奇怪了。如果你知道，欢迎留言共同探讨*************–

如果需要重新载入，则不需要做任何修改。不过如果需要在重新载入过程中保存之前的操作内容或数据，则需要保存之前的数据。然后在activity的onCreate()中取出来。当然，如此就不能设置android:configChanges()了，否则就不会调用onCreate()方法。那么数据可以保存在哪呢？Android中四种存储方法都可以，另外，还可以用Android为我们提供了onRetainNonConfigurationInstance()方法来暂时保存数据。

下面为此举个例子：

保存临时图片：

@Override
public Object onRetainNonConfigurationInstance() {
final LoadedPhoto[] list = new LoadedPhoto[numberOfPhotos];
    keepPhotos(list);
return list;
}
之后便可以在activity的onCreate()函数中实现重新调用临时文件，在代码中需要判断系统是否需要重新加载临时文件。以下是放在OnCreate()函数中加载临时文件的代码：

private void loadPhotos() {
final Object data = getLastNonConfigurationInstance();

// The activity is starting for the first time, load the photos from Flickr


if (data == null) {
        mTask = new GetPhotoListTask().execute(mCurrentPage);
    } else {
// The activity was destroyed/created automatically, populate the grid
// of photos with the images loaded by the previous activity
final LoadedPhoto[] photos = (LoadedPhoto[]) data;
for (LoadedPhoto photo : photos) {
            addPhoto(photo);
        }
    }
}
对于大多数的情况并不需要做如上的操作，所以需要谨慎使用这个行文，毕竟最好的行为也并不适用于所有情况，如果应用的不好反而会给程序带来不必要的麻烦。

如果要彻底禁止翻转，可以设置android:screenOrientation的属性为nosensor，如此就可以忽略重力感应带来的麻烦了。不过不知道为什么，在模拟器上不管用，听别人说在真机上是正确的，我没有真机，等有了真机再试试看。


34	命令行adb启动应用程序

	$adb shell am start -n <package>/<package>.<activity>

35	android屏幕禁止休眠的方法

	实现这一功能的方法有两种，一种是在Manifest.xml文件里面声明，一种是在代码里面修改LayoutParams的标志位。具体如下：

	1、在Manifest.xml文件里面用user-permission声明。代码如下：
   		<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>

　　	这种方法，在安装apk时，系统会提示安装人是否允许使用禁止休眠功能。

	2、在程序中用代码实现。代码如下：
	getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, 		WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

复制代码
　　把这段代码加在setContentView(R.layout.main)之前即可
　　这种方法，安装时，不会提示安装人是否允许使用禁止休眠功能



36	ANDROID 画图之抗锯齿


	在画图的时候，图片如果旋转或缩放之后，总是会出现那些华丽的锯齿。其实Android自带了解决方式。
   	 方法一：给Paint加上抗锯齿标志。然后将Paint对象作为参数传给canvas的绘制方法。
	Java代码  	paint.setAntiAlias(true);
   	 方法二：给Canvas加上抗锯齿标志。
	有些地方不能用paint的，就直接给canvas加抗锯齿，更方便。
	Java代码  	canvas.setDrawFilter(new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG|Paint.FILTER_BITMAP_FLAG));



37	android 的invalidate与postinvalidate的用法

	根据Android SDK api文档说明 invalidate 方法是用来更新视图（View）的方法，不过这东西的用法比较古怪 invalidate 方法如果你直接在主线程中调用，是看不到任何更新的。如果跟线程结合使用的话比如在下面的代码中就会抛出异常 UIThread implements Runnable{ public voi
　　
根据Android SDK api文档说明
invalidate 方法是用来更新视图（View）的方法，不过这东西的用法比较古怪
invalidate 方法如果你直接在主线程中调用，是看不到任何更新的。
如果跟线程结合使用的话
比如在下面的代码中就会抛出异常

UIThread implements Runnable{
public void run(){
  invalidate();
  }
}
上面的代码会抛出Only the original thread that created a view hierarchy can touch its views。
怎么样解决上面的问题呢，如果你有两个View，你需要一个View用来显示当前的状态，一个Thread去下载网络数据
或者是读取文件等，这些数据读取完毕后你要更新View到当前屏幕上怎么办呢。看看下面的代码，也许可以帮助你

第一种解决方案是：
class UIUpdateThread implements Runnable{

            public void run() {
                try {
                    Thread.sleep(1000*5);
                    mHandler.post(mUpdateResults);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }

             final Handler mHandler = new Handler();
                final Runnable mUpdateResults = new Runnable() {
                    public void run() {
                        invalidate(); //更新视图
                    }
                };

}
你必须实现一个Handler.然后再你下载数据的线程中放上一个mHandler.post(mUpdateResults);这样就可以了。

第2中方案比较简单

LoadDataThread implements Runnable{
public void run(){
   doLoadData();
   mHandler.sendMessage(mHandler.obtainMessage()); //这里系统会自动调用handleMessage；这样就可以更新视图了
   }
}

  Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            // 这里处理视图需要更新的代码。

        }
   };

37	android隐藏titlebar
	代码中
	requestWindowFeature(Window.FEATURE_NO_TITLE);requestWindowFeature(Window.FEATURE_NO_TITLE);
	代码中，全屏（同时隐藏statubar）
	getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN);

	manifest.xml中
	android:theme="@android:style/Theme.Black.NoTitleBar"
	代码中，全屏
	android:theme="@android:style/Theme.Black.NoTitleBar.FullScreen"

WindowManager wm = (WindowManager)this.getApplication().getSystemService(Context.WINDOW_SERVICE);

38	设置textView中文字滚动效果（代码，xml中都要添加）
	xml中添加
	android:ellipsize="marquee"
       android:singleLine="true"
       android:marqueeRepeatLimit="marquee_forever"
	代码中添加
	textView.setMovementMethod(ScrollingMovementMethod.getInstance());
	同时，当前textview获得焦点时，才会滚动显示
39	更新listview中的某一项
	直接获得listview当前项的view，直接更新


40	除去string 中的html标签
      public  String html2Text(String inputString) {
      String htmlStr = inputString; //含html标签的字符串
      String textStr ="";
      java.util.regex.Pattern p_script;
      java.util.regex.Matcher m_script;
      java.util.regex.Pattern p_style;
      java.util.regex.Matcher m_style;
      java.util.regex.Pattern p_html;
      java.util.regex.Matcher m_html;

      try {
       String regEx_script = "<[/s]*?script[^>]*?>[/s/S]*?<[/s]*?//[/s]*?script[/s]*?>"; //定义script的正则表达式{或<script>]*?>[/s/S]*?<//script> }
       String regEx_style = "<[/s]*?style[^>]*?>[/s/S]*?<[/s]*?//[/s]*?style[/s]*?>"; //定义style的正则表达式{或<style>]*?>[/s/S]*?<//style> }
          String regEx_html = "<[^>]+>"; //定义HTML标签的正则表达式

          p_script = Pattern.compile(regEx_script,Pattern.CASE_INSENSITIVE);
          m_script = p_script.matcher(htmlStr);
          htmlStr = m_script.replaceAll(""); //过滤script标签

          p_style = Pattern.compile(regEx_style,Pattern.CASE_INSENSITIVE);
          m_style = p_style.matcher(htmlStr);
          htmlStr = m_style.replaceAll(""); //过滤style标签

          p_html = Pattern.compile(regEx_html,Pattern.CASE_INSENSITIVE);
          m_html = p_html.matcher(htmlStr);
          htmlStr = m_html.replaceAll(""); //过滤html标签

       textStr = htmlStr;

      }catch(Exception e) {
                  System.err.println("Html2Text: " + e.getMessage());
      }

      return textStr;//返回文本字符串
    }



41	adb shell命令启动服务，发送广播(开机启动intent：<action android:name="android.intent.action.BOOT_COMPLETED"/>)
	adb shell
	am startservice <INTENT>
	am broadcast <INTENT>

42	监听网络状态方法（在service中执行）

	 mTelephonyMgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
        mTelephonyMgr.listen(mPhoneStateListener,  PhoneStateListener.LISTEN_DATA_CONNECTION_STATE);

    	private PhoneStateListener mPhoneStateListener = new PhoneStateListener(){









        @Override
        public void onDataConnectionStateChanged(int state) {
           switch(state){
                case TelephonyManager.DATA_DISCONNECTED://network 断开
                    Log.d(TAG,"....................network disable..............................");
                   // mHandler.sendEmptyMessage(CANCEL_ALARM);
                    break;
               case TelephonyManager.DATA_CONNECTING://network is connecting
                   Log.d(TAG,"....................network is connecting.............................");
                   // mHandler.sendEmptyMessage(CANCEL_ALARM);
                    break;
               case TelephonyManager.DATA_CONNECTED://network connected
                   Log.d(TAG,"....................network connected............................");
                  // mHandler.sendEmptyMessage(SET_ALARM);
                   break;
          	 }
      	  }
   	 };

	其中要在xml文件中添加权限
	 <uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>

	或者接受网络状态链接的广播
 	if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)
                    || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {

                NetworkInfo info = (NetworkInfo)(intent
                        .getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO));
                if (info != null) {
                    if (info.isConnected()) {
                        Log.d(TAG,"News.info.isConnected() : " + info.isConnected());
                        downLoadInit();
                        //setAlarm();
                   }else{
                       Log.d(TAG,"News.info.isConnected() : " + !info.isConnected());
                       //cancelAlarm();
                    }
                }
            }

43	重启modeom
	echo 0 > /sys/devices/platform/u6300_modem/power_state
	ls /dev/ttyUSB*

44	修改listview中的某一项，及时刷新
	（1）获得当前选种项，view，直接修改内容
	（2）记录当前选择项，调用adapter的，notifyDataSetChanged()方法，adapter提供设置当前选种项position的方法，
	在getView（）方法中，对当前选中项进行处理， 如，convertView.setBackgroundDrawable(mBlueDrawable);
            convertView.findViewById(R.id.news_content).setSelected(true);//针对跑马灯效果，设置listview的 android:focusable="true"

45	listview getChildAt()方法，at中取值只能取当前屏幕中可见项目的（0到n-1）n为当前屏幕看见item的数目
	取位于listview的第y个item，要通过getChildAt(y-getFirstVisiblePosition())即可获得第y个item，直接通过getChildAt（y）取，会得到null

46	layout.xml中包含另一个layout可以用在当前layout文件中，添加<include layout="@layout/layoutid" />

47	android:textAppearance="?android:attr/textAppearanceLarge"
	android:textAppearance="?android:attr/textAppearanceMedium"
	android:textAppearance="?android:attr/textAppearanceSmall"

48	策略模式示例，TabHost.java    IndicatorStrategy

49	代码中获取布局文件
	 LinearLayout dialog = (LinearLayout)LayoutInflater
        .from(mContext)
        .inflate(R.layout.dialog_layout, null);

50	判断sdcard是否存在，文件是否存在
	 private boolean isFileExistInSdcardPOI(){
        File file = new File(mBasePath);
        String status = Environment.getExternalExtSDStorageState();
        boolean isSdCardExist = status.equals(Environment.MEDIA_MOUNTED);
        if(isSdCardExist){
            if(file.exists()){
                File[] files = file.listFiles();
                if(files!=null && files.length>0){
                    return true;
                }
            }
        }
        return false;
    }


51	listview,item与item项中内容都获得单击事件
	通过adapter引入listview-item.xml，根结点设置    android:descendantFocusability="blocksDescendants" 	(The ViewGroup will block its descendants from receiving focus. )
	item中，获得单击的item，设置	 android:focusable="false"
	在adapter中，设置item的setOnClickListener(OnClickListener)
	在代码中设置listview的setOnItemClickListener(OnItemClickListener)

	android:descendantFocusability值
	beforeDescendants	0	 The ViewGroup will get focus before any of its descendants.
	afterDescendants	1	The ViewGroup will get focus only if none of its descendants want it.
	blocksDescendants	2	The ViewGroup will block its descendants from receiving focus.

	listview item中可能有button，此时，若同时设置button和listitem的selector，点击listitem时，button背景会改变
	android：duplicateParentState=”false“不管用
	解决办法，修改button背景，为默认，设置button的ontouch事件，在onkeydown与onkeyup时，分别设置button的背景


52	过滤文件夹目录下文件类型xml示例（）
	File file = new File(Constants.PATH_CARBOX+Constants.PATH_ROADBOOK);

        File[] files = file.listFiles(new XmlFileFilter());//file.listFiles()表示显示目录下所有文件

 	private static class XmlFileFilter implements FileFilter {

       	public boolean accept(File pathname) {
          	if (Constants.LOG_ON)  Log.d(TAG, "==XmlFileFilter== filepath = " + pathname.getPath());
            	if (pathname.getPath().endsWith(Constants.SUFFIX)) {
               	 return true;
           	 } else {
              	  return false;
           	 }
        	}

   	}

53	通过网络获取当前位置的经纬度
	今天在Android项目中要实现一个通过GPS或NetWork来获取当前移动终端设备的经纬度功能。要实现该功能要用到Android Framework 中的 LocationManager 类。下面我就直接贴上主要的代码说明如何实现通过GPS或NetWork来获取实时位置的经纬度。
01	private double latitude=0.0;
02	private double longitude =0.0;
03
04	LocationManager locationManager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
05	        if(locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)){
06	            Location location = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
07	            if(location != null){
08	                latitude = location.getLatitude();
09	                longitude = location.getLongitude();
10	                }
11	        }else{
12	            LocationListener locationListener = new LocationListener() {
13
14	                // Provider的状态在可用、暂时不可用和无服务三个状态直接切换时触发此函数
15	                @Override
16	                public void onStatusChanged(String provider, int status, Bundle extras) {
17
18	                }
19
20	                // Provider被enable时触发此函数，比如GPS被打开
21	                @Override
22	                public void onProviderEnabled(String provider) {
23
24	                }
25
26	                // Provider被disable时触发此函数，比如GPS被关闭
27	                @Override
28	                public void onProviderDisabled(String provider) {
29
30	                }
31
32	                //当坐标改变时触发此函数，如果Provider传进相同的坐标，它就不会被触发
33	                @Override
34	                public void onLocationChanged(Location location) {
35	                    if (location != null) {
36	                        Log.e("Map", "Location changed : Lat: "
37	                        + location.getLatitude() + " Lng: "
38	                        + location.getLongitude());
39	                    }
40	                }
41	            };
42	            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,1000, 0,locationListener);
43	            Location location = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
44	            if(location != null){
45	                latitude = location.getLatitude(); //经度
46	                longitude = location.getLongitude(); //纬度
47	            }
48	        }
同时别忘了在AndroidManifest.xml文件中加入如下权限：
1	<!-- 连接互联网Internet权限 -->
2	<uses-permission android:name="android.permission.INTERNET" />
3	<!-- GPS定位权限 -->
4	<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
5	<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />


54 	设置icon的selector
	<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:state_focused="false" android:state_selected="false"
        android:state_pressed="false" android:drawable="@drawable/tab_stay_icon_focus"/>

    <item android:state_focused="false" android:state_selected="true"
        android:state_pressed="false" android:drawable="@drawable/tab_stay_icon_unfocus"/>

    <item android:state_focused="true" android:state_selected="false"
        android:state_pressed="false" android:drawable="@drawable/tab_stay_icon_unfocus"/>

    <item android:state_focused="true" android:state_selected="true"
        android:state_pressed="false" android:drawable="@drawable/tab_stay_icon_unfocus"/>

</selector>


  <selector xmlns:android="http://schemas.android.com/apk/res/android">
      <item android:state_window_focused="false" android:state_enabled="true"
          android:drawable="@drawable/custom_btn_normal_light" />
      <item android:state_window_focused="false" android:state_enabled="false"
         android:drawable="@drawable/custom_btn_disable" />
      <item android:state_pressed="true"
          android:drawable="@drawable/custom_btn_pressed" />
      <item android:drawable="@drawable/custom_btn_normal_light" />
  </selector>

55	xml文件解析
	（1）实例RoadBookHandler继承DefaultHandler.java,
	（2）定义RoadBookInfo.java（model）
	（3）解析
	 DefaultHandler handler = new RoadBookHandler((RoadBookInfo) obj);
	 SAXParserFactory spf = SAXParserFactory.newInstance();
        try {
            SAXParser sp = spf.newSAXParser();
            XMLReader xr = sp.getXMLReader();
            xr.setContentHandler(handler);
            xr.parse(new InputSource(in)); //in = new FileInputStream(new File(filePath))
            return true;
        } catch (ParserConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (SAXException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


56	软引用，弱引用，虚引用
    * A SoftReference should be cleared and enqueued as late as possible, that is, in case the VM is in danger of running out of memory.
	当VM 不清理资源就会出现OutOfMemoryError()时，弱引用对象将被垃圾回收器回收/softreference 对象会一直存在,知道内存不足时,才会清理
    * A WeakReference may be cleared and enqueued as soon as is known to be weakly-referenced.
	垃圾回收器扫描时，发现弱引用对象就会回收资源
	PhantomReference（虚引用）

57	File[] files = file.listFiles(new XmlFileFilter());//过滤xml文件

	private static class XmlFileFilter implements FileFilter {

        public boolean accept(File pathname) {
            if (Constants.LOG_ON)  Log.d(TAG, "==XmlFileFilter== filepath = " + pathname.getPath());
            if (pathname.getPath().endsWith(Constants.SUFFIX)) { //public static final String SUFFIX = ".xml";
                return true;
            } else {
                return false;
            }
        }

    }

58	android下xml文件解析：
	SAX	SAX是一个解析速度快并且占用内存少的xml解析器，非常适合用于Android等移动设备。 SAX解析XML文件采用的是事件驱动，也就是说，它并不需要解析完整个文档，在按内容顺序解析文档的过程中，SAX会判断当前读到的字符是否合法XML语法中的某部分，如果符合就会触发事件。所谓事件，其实就是一些回调（callback）方法，这些方法(事件)定义在ContentHandler接口。
	DOM	DOM解析XML文件时，会将XML文件的所有内容读取到内存中，然后允许您使用DOM API遍历XML树、检索所需的数据。使用DOM操作XML的代码看起来比较直观，并且，在某些方面比基于SAX的实现更加简单。但是，因为DOM需要将XML文件的所有内容读取到内存中，所以内存的消耗比较大，特别对于运行Android的移动设备来说，因为设备的资源比较宝贵，所以建议还是采用SAX来解析XML文件，当然，如果XML文件的内容比较小采用DOM是可行的。
	PULL	除了可以使用 SAX和DOM解析XML文件，大家也可以使用Android内置的Pull解析器解析XML文件。 Pull解析器的运行方式与 SAX 解析器相似。它提供了类似的事件，如：开始元素和结束元素事件，使用parser.next()可以进入下一个元素并触发相应事件。事件将作为数值代码被发送，因此可以使用一个switch对感兴趣的事件进行处理。当元素开始解析时，调用parser.nextText()方法可以获取下一个Text类型元素的值。

	（1）	SAX	Simple API for XML(SAX)
	SAXParserFactory spf = SAXParserFactory.newInstance();

	SAXParser saxParser = spf.newSAXParser(); //创建解析器

	//设置解析器的相关特性，http://xml.org/sax/features/namespaces = true 表示开启命名空间特性

	saxParser.setProperty("http://xml.org/sax/features/namespaces",true);

	XMLContentHandler handler = new XMLContentHandler();	//XMLContentHandler 继承于当DefaultHandler();

	saxParser.parse(inStream, handler);	//inStream xml文件的inputStream

	inStream.close();

	(2)	DOM	Document Object Model(DOM)

	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

	DocumentBuilder builder = factory.newDocumentBuilder();

	Document dom = builder.parse(inStream);

	Element root = dom.getDocumentElement();

	NodeList items = root.getElementsByTagName("person");//查找所有person节点

	for (int i = 0; i < items.getLength(); i++) {

	Person person = new Person();

	//得到第一个person节点

	Element personNode = (Element) items.item(i);

	//获取person节点的id属性值

	person.setId(new Integer(personNode.getAttribute("id")));

	//获取person节点下的所有子节点(标签之间的空白节点和name/age元素)

	NodeList childsNodes = personNode.getChildNodes();

	for (int j = 0; j < childsNodes.getLength(); j++) {

	Node node = (Node) childsNodes.item(j); //判断是否为元素类型

		if(node.getNodeType() == Node.ELEMENT_NODE){
			Element childNode = (Element) node; //判断是否name元素

   			if ("name".equals(childNode.getNodeName())) { //获取name元素下Text节点,然后从Text节点获取数据

       			person.setName(childNode.getFirstChild().getNodeValue());

   			} else if (“age”.equals(childNode.getNodeName())) {

            			 person.setAge(new Short(childNode.getFirstChild().getNodeValue()));

   			}

		}

       }

   	persons.add(person);

	inStream.close();

	(3)PULL

 	XmlPullParserFactory factory = XmlPullParserFactory.newInstance();

	XmlPullParser parser = factory.newPullParser();

	parser.setInput(inStream, "UTF-8");

	int eventType = parser.getEventType();

	Person currentPerson = null;

	List<Person> persons = null;

	while (eventType != XmlPullParser.END_DOCUMENT) {

	switch (eventType) {

	case XmlPullParser.START_DOCUMENT://文档开始事件,可以进行数据初始化处理

			persons = new ArrayList<Person>();

			break;

	case XmlPullParser.START_TAG://开始元素事件

			String name = parser.getName();

		if (name.equalsIgnoreCase("person")) {

			currentPerson = new Person();

			currentPerson.setId(new Integer(parser.getAttributeValue(null, "id")));

		} else if (currentPerson != null) {

			if (name.equalsIgnoreCase("name")) {

				currentPerson.setName(parser.nextText());// 如果后面是Text元素,即返回它的值

			} else if (name.equalsIgnoreCase("age")) {

				currentPerson.setAge(new Short(parser.nextText()));

			}

		}

		break;

	case XmlPullParser.END_TAG://结束元素事件

		if (parser.getName().equalsIgnoreCase("person") && currentPerson != null) {

			persons.add(currentPerson);

			currentPerson = null;

		}

		break;

	}

	eventType = parser.next();

	}

	inStream.close();

	return persons;

	return null;
	}


59	使用Pull解析器生成XML文件

	有些时候，我们需要生成一个XML文件，生成XML文件的方法有很多，如：可以只使用一个StringBuilder组拼XML内容，然后把内容写入到文件中；或者使用DOM API生成XML文件，或者也可以使用pull解析器生成XML文件，这里推荐大家使用Pull解析器。

60	getMeasureHeight()和getMeasureWidth()	onMeasure(),onLayout()中调用
	getHeight()和getWidth()	最后在屏幕显示的长，宽

61	集合类总结
	Collection	子类	List	有序，可以有重复元素	ArrayList	LinkedList
				Set	无序，无重复元素		HashSet（速度快）	TreeSet（有序）	LinkedHashSet
	Map	子类	HashMap	TreeMap（有序）	LinkedHashMap

62	响应back键
	 @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // TODO Auto-generated method stub
        if(keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0){

        }
        return super.onKeyDown(keyCode, event);
    }


63	<merge/>标签用法	详见：docs/resources/articles/layout-tricks-merge.html
	* <merge /> can only be used as the root tag of an XML layout（layout的根元素）
	* When inflating a layout starting with a <merge />, you must specify a parent ViewGroup and you must set attachToRoot to true (see the documentation for inflate(int, android.view.ViewGroup, boolean) method)（例如：LayoutInflater.from(context).inflate(R.layout.okcancelbar, this, true);
）

64	service activity之间通讯
	（1）activity bindservice 可以调用servcie中的public方法
	（2）service  可以发广播，通知activity进行处理
	（3）activity 可以建立接口，在service中实现，实现回调

65	sqlite 分页显示
	直接用sql语句：例如	select * from tablename limit 10 100;从第十条到第100条，起始条为0
	用contentResolver来查询(直接在orderBy后面添加limit 语句 例如	limit 30 (取前三十条))
	query(
	     db,            // The database to query
            projection,    // The columns to return from the query
            selection,     // The columns for the where clause
            selectionArgs, // The values for the where clause
            null,          // don't group the rows
            null,          // don't filter by row groups
            orderBy + " limit 10,30")


66	service私有	（1）不设置intent fillter
			（2）在manifest.xml中添加<servcie>标签下添加<android:exported=false>

67	service，thread区别	（1）service后台运行，与用户无交互时仍运行，默认运行在主线里，
				（2）thread用户与用户交互，运行与非主线程时
68	Toast	(1)Toast.makeText(Context  context, int resId, int duration)
		(2)自定义view	Toast toast = new Toast(Context  context);	toast.setView(customView);

69	计时器功能 CountDownTimer	//其还有两个方法为start()开始计时，cancel()取消计时，并不会调用finish方法

	 class MyCountDownTimer extends CountDownTimer{


        public MyCountDownTimer(long millisInFuture, long countDownInterval) { //间隔五秒，则 new MyCountDownTimer(5000,1000);后面参数为间隔
            super(millisInFuture, countDownInterval);
            // TODO Auto-generated constructor stub
        }

        @Override//计时结束时调用
        public void onFinish() {
            // TODO Auto-generated method stub
            Log.d(TAG,"CountDownTimer finish................!");
            Toast.makeText(mContext, "finish................", Toast.LENGTH_LONG).show();
        }

        @Override//每一次过间隔时间时调用
        public void onTick(long millisUntilFinished) {
            // TODO Auto-generated method stub
            Log.d(TAG,"CountDownTimer onTick................!");
            //Toast.makeText(mContext, "onTick................", Toast.LENGTH_LONG).show();
        }

    }

70	将源码作为一个工程导入eclipse
	build/development/ide/eclipse/.classpath 	拷贝到 build目录下
	在eclipse中直接导入已经存在的工程


71	建立一个透明activity
	<style name="BackgroundOnly">
       	<item name="android:windowBackground">@null</item>
        	<item name="android:windowContentOverlay">@null</item>
        	<item name="android:windowAnimationStyle">@null</item>
        	<item name="android:windowNoTitle">true</item>k
        	<item name="android:windowNoDisplay">true</item>
        	<item name="android:windowIsFloating">true</item>
       </style>

72	inputStream 与String相互转换
	String --> InputStream 	InputStream is = new ByteArrayInputStream(str.getBytes[]);
	InputStrem --> String

	public String convertStreamToString(InputStream is) throws IOException {

        if (is != null) {
            StringBuilder sb = new StringBuilder();
            String line;

            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                while ((line = reader.readLine()) != null) {
                    sb.append(line).append("\n");
                }
            } finally {
                is.close();
            }
            return sb.toString();
        } else {
            return "";
        }
    }

73	ProgressDialog  back键，取消Progressdialog
	Progressdialog.setOnCancelListener(new DialogInterface.OnCancelListener(){
		@Override
        	public void onCancel(DialogInterface dialog) {
            	// TODO Auto-generated method stub
            		isContinue = false;
        	}
	});
	可以实现DialogInterface.OnCancelListener接口，在其cancel方法中，进行资源清理工作

74
	<manifest ... >
		<uses-permission android:name="android.permission.BLUETOOTH" />	蓝牙链接权限
		<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />	蓝牙设备搜索，蓝牙设置权限（与BLUETOOTH一起使用）
	</manifest>

75	蓝牙协议pbap  Phone Book Access Profile
	PSE	PhoneBook Server Equipment	(含有phonebook 源   手机)
	PCE	PhoneBook Client Equipment	(要获取的信息 车载)

	pb	PhoneBook
	ich	Incoming Call History
	och	OutGoing Call History
	mch	Missing Call History
	cch	Combined Call History


	The local phone book information is located under the telecom folder.(根目录下/telecom/pb..)
	When the PSE also contains a SIM card, SIM card phone book information shall be located under the SIM1/telecom/ folder(根目录下/SIM1/telecom/pb)
	详细请见pbap协议p15

	pbap	(1)下载	下载整个pb	PullPhonebook
		(2)浏览		以单条数据的vcard形式下载

76	电话按键音实现	ToneGenerator 详见电话

77	button selector 实例（按下释放效果实例）
	<selector xmlns:android="http://schemas.android.com/apk/res/android">
    		<item android:state_pressed="true"
        		android:drawable="@drawable/icar_mode_car_on" />
    		<item android:state_focused="true"
       		android:drawable="@drawable/icar_mode_car_on" />
   		<item
        		android:drawable="@drawable/icar_mode_car" />
	</selector>

78	android service activity 之间复杂信息的传输	可以实现application

79	NANP 	North American Number Plan (北美编号计划)
	JAPAN

80 	SDCard mount and unmount 监听

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Environment;
import android.util.Log;

public class SDCardMountBroadcastReceiver extends BroadcastReceiver{

    private static final String TAG = "SDCardMountBroadcastReceiver";

    public interface SDCardMountResponse {
        void onSDCardMount();

        void onSDCardUnMount();
    }

    private SDCardMountResponse mSDCardMountResponse;

    public void setSDCardMountResponse(SDCardMountResponse mSDCardMountResponse) {
        this.mSDCardMountResponse = mSDCardMountResponse;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (Intent.ACTION_MEDIA_EJECT.equals(intent.getAction())) {
            String ejectedPath = intent.getData().getPath();

            if (Environment.getExternalSDStorageDirectory().toString().equals(ejectedPath)) {
                mSDCardMountResponse.onSDCardUnMount();
            } else if (Environment.getExternalUDiskStorageDirectory().toString().equals(ejectedPath)) {

            } else if (Environment.getExternalExtSDStorageDirectory().toString().equals(ejectedPath)) {

            }
        }
        if (Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(intent.getAction())) {
            String ejectedPath = intent.getData().getPath();
            if (Environment.getExternalSDStorageDirectory().toString().equals(ejectedPath)) {
                mSDCardMountResponse.onSDCardMount();
            } else if (Environment.getExternalUDiskStorageDirectory().toString().equals(ejectedPath)) {

            } else if (Environment.getExternalExtSDStorageDirectory().toString().equals(ejectedPath)) {

            }
        }
    }

}


	 activity中实现
	 mSDCardMountBroadcastReceiver = new SDCardMountBroadcastReceiver();
        mSDCardMountBroadcastReceiver.setSDCardMountResponse(this);
        IntentFilter sdCardIntentFilter = new IntentFilter();
        sdCardIntentFilter.addAction(Intent.ACTION_MEDIA_EJECT);
        sdCardIntentFilter.addDataScheme("file");
        sdCardIntentFilter.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);

        this.registerReceiver(mSDCardMountBroadcastReceiver, sdCardIntentFilter);

81 	android MimeType 类型	android.webkit.MimeTypeMap	MimeTypeMap.java() 	多用途互联网邮件扩展（MIME Multipurpose Internet Mail Extensions）
	格式	类型/子类型	例如	text/plain（纯文本）
	类型主要分以下几种形式：
	Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；
       Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；
       Application：用于传输应用程序数据或者二进制数据；
       Message：用于包装一个E-mail消息；
       Image：用于传输静态图片数据；
       Audio：用于传输音频或者音声数据；
       Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。

82 	linux下蓝牙协议栈（集成在linux内核中）	bluez
	kenel BB（Base Band）RF（Radio Frequency）
	底层 	HCI	Host Control Interface	hcitool	扫描远端设备，显示地址名称	hcitool scan
	L2CAP						sdptool	浏览远端设备SDP服务

	sdptool browse 00:02:72:B0:00:26		浏览00:02:72:B0:00:26所提供的服务

	sdptool browse 00:02:72:B0:00:26 浏览地址为 00:02:72:B0:00:26的设备所提供的服务

	sdptool search 0x1112 00:02:72:B0:00:26 查找地址为00:02:72:B0:00:26的设备上的Headset Audio Gateway服务。

	hcidump -tXV	打印详细信息

	hcidump -tXV > /sdcard/btlog.txt	将log信息打印到sdcard的btlog.txt文件中

83 	判断系统是否有sim卡或usim卡（wcdma），TelephonyManager.getDefault().hasIccCard()

	boolean hasSim = ((TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE)).hasIccCard();

	int state = ((TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE)).getSimState();获得sim卡状态，详情看TelephonyManager

	absent，pin locked，pun locked，network pin Locked，unknown

	查询sim卡联系人 uri	content://icc/adn或者content：//sim/adn（ADN是sim卡数据的存储格式）

84	联系人批量添加	详情可见 VCardEntry

	ArrayList<ContentProviderOperation> operationList =
                new ArrayList<ContentProviderOperation>();
            ContentProviderOperation.Builder builder =
                ContentProviderOperation.newInsert(RawContacts.CONTENT_URI);
            builder.withValue(RawContacts.ACCOUNT_NAME, null);
            builder.withValue(RawContacts.ACCOUNT_TYPE, null);
            operationList.add(builder.build());
            if(!TextUtils.isEmpty(name)){
                builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
                builder.withValueBackReference(StructuredName.RAW_CONTACT_ID, 0);
                builder.withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
                builder.withValue(StructuredName.DISPLAY_NAME, name);
                operationList.add(builder.build());
            }

            if(!TextUtils.isEmpty(number)){
                builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
                builder.withValueBackReference(Phone.RAW_CONTACT_ID, 0);
                builder.withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
                builder.withValue(Phone.NUMBER, number);
                operationList.add(builder.build());
            }

            try {
                ContentProviderResult[] results = mContext.getContentResolver().applyBatch(
                            ContactsContract.AUTHORITY, operationList);
                Log.d(TAG,"results[0].uri :" + results[0].uri);
                return results[0].uri;
            } catch (RemoteException e) {
                Log.e(TAG, String.format("%s: %s", e.toString(), e.getMessage()));
                return null;
            } catch (OperationApplicationException e) {
                Log.e(TAG, String.format("%s: %s", e.toString(), e.getMessage()));
                return null;
            }

85	近场技术（NFC Near Field Conmmunication）	基于FIRD 	传输距离在20cm之内

86	启动	Setting activity
	am start -n com.android.settings/com.android.settings.Settings

87	数据库异步处理AsyncQueryHandler

    private static class QueryHandler extends AsyncQueryHandler {
        protected final WeakReference<ContactsListActivity> mActivity;
        protected boolean mLoadingJoinSuggestions = false;

        public QueryHandler(Context context) {
            super(context.getContentResolver());
            mActivity = new WeakReference<ContactsListActivity>((ContactsListActivity) context);
        }

        public void setLoadingJoinSuggestions(boolean flag) {
            mLoadingJoinSuggestions = flag;
        }

        @Override
        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
            final ContactsListActivity activity = mActivity.get();
            if (activity != null && !activity.isFinishing()) {

                // Whenever we get a suggestions cursor, we need to immediately kick off
                // another query for the complete list of contacts
                if (cursor != null && mLoadingJoinSuggestions) {
                    mLoadingJoinSuggestions = false;
                    if (cursor.getCount() > 0) {
                        activity.mAdapter.setSuggestionsCursor(cursor);
                    } else {
                        cursor.close();
                        activity.mAdapter.setSuggestionsCursor(null);
                    }

                    if (activity.mAdapter.mSuggestionsCursorCount == 0
                            || !activity.mJoinModeShowAllContacts) {
                        startQuery(QUERY_TOKEN, null, activity.getContactFilterUri(
                                        activity.getTextFilter()),
                                CONTACTS_SUMMARY_PROJECTION,
                                Contacts._ID + " != " + activity.mQueryAggregateId
                                        + " AND " + CLAUSE_ONLY_VISIBLE, null,
                                activity.getSortOrder(CONTACTS_SUMMARY_PROJECTION));
                        return;
                    }

                    cursor = activity.getShowAllContactsLabelCursor(CONTACTS_SUMMARY_PROJECTION);
                }

                final WrapperListView wrapper = (WrapperListView) activity.findViewById(R.id.main_list);
                final View searchView = activity.findViewById(R.id.searchView);
                if (cursor.getCount() <= 0) {

                    wrapper.setVisibility(View.GONE);
                    searchView.setVisibility(View.GONE);

                    if (activity.mDeleteMode) {
                        activity.finish();
                    } else {
                        activity.mEmptyContainer.setVisibility(View.VISIBLE);
                    }
                } else {
                    wrapper.setVisibility(View.VISIBLE);
                    searchView.setVisibility(View.VISIBLE);
                }

                activity.mAdapter.changeCursor(cursor);

                // Now that the cursor is populated again, it's possible to restore the list state
                if (activity.mListState != null) {
                    activity.mList.onRestoreInstanceState(activity.mListState);
                    activity.mListState = null;
                }
            } else {
                if (cursor != null) {
                    cursor.close();
                }
            }
        }
    }







90	获取setting设置值
	final String enabledStr = Settings.Secure.getString(
                mContext.getContentResolver(),
                Settings.Secure.ENABLED_INPUT_METHODS);

91	获取edittext光标前后字符
	if(editText1!=null && editText1.onCheckIsTextEditor()){
            InputConnection ipc = editText1.onCreateInputConnection(new EditorInfo());
            Log.d("news : " ,"ipc : "  + ipc.getTextBeforeCursor(1,0));
	     Log.d("news : " ,"ipc : "  + ipc.getTextAfterCursor(1,0));
        }

92	android string.xml文件中,字符串添加空格	&#160;	代表一个空格


93	Adapter-->Filter
	CursorAdpater  和	ArrayAdapter都内置实现filter
	ArrayAdapter	执行fiter()后,arry可能不更新,此时需要我们在ArrayAdapter中实现自定义filter,具体代码可以参考ArrayAdapter代码.


94	设置animation格式动画,及其调用
	xml文件,文件名为:download_dialog_anim.xml
	<?xml version="1.0" encoding="utf-8"?>
	<animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    	android:oneshot="false">
		<item android:drawable="@drawable/download_anim1" android:duration="200" />
   		<item android:drawable="@drawable/download_anim2" android:duration="200" />
   		<item android:drawable="@drawable/download_anim3" android:duration="200" />
   	 	<item android:drawable="@drawable/download_anim4" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim5" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim6" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim7" android:duration="200" />
	   	<item android:drawable="@drawable/download_anim8" android:duration="200" />
 	   	<item android:drawable="@drawable/download_anim9" android:duration="200" />
 	   	<item android:drawable="@drawable/download_anim10" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim11" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim12" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim13" android:duration="200" />
  	  	<item android:drawable="@drawable/download_anim14" android:duration="200" />
	</animation-list>


	使用
	AnimationDrawable mDownloadImageAnim = (AnimationDrawable)mContext.getResources().getDrawable(R.anim.download_dialog_anim);

	ImageView imageView = (ImageView)mDownloadDialog.findViewById(R.id.download_image);
      	imageView.setBackgroundDrawable(mDownloadImageAnim);
       mDownloadDLHandler.post(new StartAnimationRunnable());//启动动画
	mDownloadDLHandler.post(new StopAnimationRunnable());//停止动画

	private class StartAnimationRunnable implements Runnable{

        @Override
        public void run() {
            // TODO Auto-generated method stub
            startAnimation();
        }
    }

    private class StopAnimationRunnable implements Runnable{

        @Override
        public void run() {
            // TODO Auto-generated method stub
            stopAnimation();
        }

    }

    private void startAnimation(){
        Log.d(TAG, "-----------------------startAnimation------------------------");
        if(mDownloadImageAnim != null){
            mDownloadImageAnim.stop();
            mDownloadImageAnim.start();
        }
    }

    private void stopAnimation(){
        if(mDownloadImageAnim != null){
            mDownloadImageAnim.stop();
        }
    }



95	TypedArray使用(可参见framework下res内容)
	attrs.xml文件
	<resources>
		<declare-styleable name="LabelView">
			<attr name="text" format="string" />
       		<attr name="textColor" format="color" />
       		<attr name="textSize" format="dimension" />
    		</declare-styleable>
	</resources>

	java中应用
	TypedArray a = context.obtainStyledAttributes(attrs,
                R.styleable.LabelView);

        CharSequence s = a.getString(R.styleable.LabelView_text);//不带默认值

        setTextColor(a.getColor(R.styleable.LabelView_textColor, 0xFF000000));//设置默认值

        int textSize = a.getDimensionPixelOffset(R.styleable.LabelView_textSize, 0);

	 a.recycle();


96	android input介绍
	/system/lib/input
	按键值的定义,代码位于源码frameworks/base/native/include/android/keycodes.h
	adb shell input keyevent 3	home键
	adb shell input keyevent 4	back键
	adb shell input keyevent 5	call键
	adb shell input keyevent 82 menu键
	adb shell text "hello" 	输入字符串

97	String相关操作(格式化输出)
		Formatter formatter = new Formatter(System.err);
       	formatter.format("%80s\n", scanner.next());//s占80个字符,右对齐;实现左对齐则%-80s
	Scanner 操作(读入一系列字符)
 	String scanSt = "this is the scanner test string,please try yourself!";
        Scanner scanner = new Scanner(scanSt);
        scanner.useDelimiter(",");//设置分割符
        while(scanner.hasNext()){
            //System.out.println(scanner.next());
            Formatter formatter = new Formatter(System.err);
            formatter.format("%-80s\n", scanner.next());
            //System.out.println(String.format("%s\n", scanner.next()));
            //System.out.println(String.format(Locale.CHINA,  "%s\n", scanner.next()));
        }


99	BluetoothAdapter	本地蓝牙设备
	BluetoothHfp	蓝牙电话(1)
	BluetoothA2dp	蓝牙音乐(2)
	BluetoothPbap	蓝牙电话本(手动)


100	Thread.dumpStack()
	以error的形式,打印出堆栈信息


Adb shell am instrument
-e class com.jayway.test.NotePadTest#testAddNote
-w com.jayway.test /android.test.InstrumentationTestRunner
-e size large(medium,small)
-e perf true -e debug true

adb shell am instrument -e class com.android.contacts.test.TwelveKeyDialerTest -w com.android.contacts.test/android.test.InstrumentationTestRunner

101	android:inputType设置文本框属性textImeMultiLine	设置输入法ExtraEdit多行显示
	textMultiLine	设textview多行

102	activity 属性android:clearTaskOnLaunch="true"(按home键回到homescreen后,进入应用,还进入主activity而非按home键时的activity)
	Activity A (启动界面	android:clearTaskOnLaunch="true")
	Activity B
	启动A后,再点击按钮启动B,点击home,返回到home screen
	a.长按home键,在recent中点击应用图标,显示B界面
	b.再点击应用图标显示A界面

103	引用系统style
	style="?android:attr/btnStyleDarkSmallNarrow"

104 	卸载程序
	 Uri packageURI = Uri.parse("package:"+packageName);
        Intent uninstallIntent = new Intent(Intent.ACTION_DELETE, packageURI);
        startActivity(uninstallIntent);

105	横竖屏设置(xml)
	android:screenOrientation="landscape"
	android:screenOrientation="portrait"
	setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
	setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)

106	Collection 总结
	List(无序,可以有重复元素)	ArrayList(一般应用) LinkedList(Quene存放顺序,插入删除效率高)
	Set(有序,无重复元素)	HashSet	TreeSet(SortSet--实现Comparable接口)	LinkedHashSet(存放的顺序)
	Map 	(key-value)
	HashMap
	LinkedHashMap
	TreeMap	(存放的顺序排序)


107	安装卸载程序广播获取安装卸载应用包名
	android.intent.action.PACKAGE_REMOVED
	android.intent.action.PACKAGE_ADDED

	广播注册
	IntentFilter intentFilter = new IntentFilter("android.intent.action.PACKAGE_REMOVED");
       intentFilter.addDataScheme("package");

	收到广播:intent.getData(); 获得URI为:"package:应用包名"
	receiver注册在onCreate(),撤销在onDestory(),则activity在后台,也可以收到广播

	private void uninstallPkg(String packageName) {
           Uri packageURI = Uri.parse("package:"+packageName);
           Intent uninstallIntent = new Intent(Intent.ACTION_DELETE, packageURI);
           getContext().startActivity(uninstallIntent);
    	}


108 	android系统自带提示音等目录
	/system/media/audio/ringtones电话铃音(alarms闹钟,notifications短消息提示音,ui系统界面声音)
	可以在sdcard上创建media/ringtones,就可以在设置铃声等目录中查到,或者直接将系统文件替换掉

109 	读setting数据库中的值
	int rentalMode = Settings.System.getInt(ContentResolver,  Settings.System.ENABLE_VEHICLE_RENTAL,0);

        mContext.getContentResolver().registerContentObserver(
                Uri.withAppendedPath(Settings.Secure.CONTENT_URI, Settings.Secure.MOBILE_DATA), false, mContextObserver);

    private ContentObserver mContextObserver = new ContentObserver(mHandler) {

        @Override
        public void onChange(boolean selfChange) {
            Log.d(TAG, "enabled chaged is :" + selfChange);
            boolean retVal = Settings.Secure.getInt(mContext.getContentResolver(),
                    Settings.Secure.MOBILE_DATA, 1) == 1;
            Log.d(TAG, "data is enabled :" + retVal +  " ; is auto download : " + isAuto());
            if(retVal){
                checkMmsToDownLoad(mContext);
            }
        }
    };




110 	onNewIntent  (Intent  intent)
	Activity 设置android:launchMode="singleTop" 或者 client 使用FLAG_ACTIVITY_SINGLE_TOP为flag startActivity(Intent)
	In either case, when the activity is re-launched while at the top of the activity stack instead of a new instance of the activity being started, 		onNewIntent() will be called on the existing instance with the Intent that was used to re-launch it.
	An activity will always be paused before receiving a new intent, so you can count on onResume() being called after this method.
	注意getIntent()仍旧获取原来的Intent.你可以用setIntent(Intent)来将原来的Intent更新为新的Intent

111    获取file文件大小
	private void initMediaSize(){
        ContentResolver cr = mContext.getContentResolver();
        InputStream input = null;
        try {
            input = cr.openInputStream(mUri);//mUri为  file:///mnt/sdcard/filename
            if (input instanceof FileInputStream) {
                // avoid reading the whole stream to get its length
                FileInputStream f = (FileInputStream) input;
                mSize = (int) f.getChannel().size();
            } else {
                while (-1 != input.read()) {
                    mSize++;
                }
            }

        } catch (IOException e) {
            // Ignore
            Log.e(TAG, "IOException caught while opening or reading stream", e);
            if (e instanceof FileNotFoundException) {
                throw new MmsException(e.getMessage());
            }
        } finally {
            if (null != input) {
                try {
                    input.close();
                } catch (IOException e) {
                    // Ignore
                    Log.e(TAG, "IOException caught while closing stream", e);
                }
            }
        }
    }

112	PackageManager

  	setApplicationEnabledSetting  (String  packageName, int newState, int flags)	//set application enabled or disabled
	newSate	COMPONENT_ENABLED_STATE_ENABLED, COMPONENT_ENABLED_STATE_DISABLED  and COMPONENT_ENABLED_STATE_DEFAULT
	flags		DONT_KILL_APP  or 0


  	setComponentEnabledSetting  (ComponentName  componentName, int newState, int flags)
	componentName 	activity,service,provider,receiver manifest


113	process and threads

	android 一个应用对应一个process 和一个main thread (UI thread)

	process 等级	(1)Foreground Process
			(2)Visible Process
			(3)Service Process
			(4)Background process
			(5)Empty process
	为防止,activity,或BroadCastRecevier 中,执行耗时任务,process被系统kill,最好在servcie中执行,而非thread中执行

	thread (1)不要阻塞ui线程(ANR 5秒)
		(2)不要在非ui线程中,操作ui控件
			解决	* Activity.runOnUiThread(Runnable)
    				* View.post(Runnable)
    				* View.postDelayed(Runnable, long)
	AsyncTask

	ANR 问题:(ActivityMnanager 与 Window manager系统服务监视的)
	(1)ui交互时间超过5秒没有返回(按键,触屏等操作)
	(2)BroadcaseReceiver onRecevie()方法中处理时间时间超过10秒

	出现ANR问题时,分析log
	logcat -b system -v time -d *:v
	(1)搜索 "ANR "
	(2)搜索	"DALVIK THREADS"
114 	activity and task
	launcher进入应用,启动一个新的task,并寻找main的activity,作为task的root activity(若此应用之前有task,即启动过,则直接进入原来启动的task)
	长按home进入,近期task

	*  When Activity A starts Activity B, Activity A is stopped, but the system retains its state (such as scroll position and text entered into forms). If the user presses the BACK key while in Activity B, Activity A resumes with its state restored.
    	* When the user leaves a task by pressing the HOME key, the current activity is stopped and its task goes into the background. The system retains the state of every activity in the task. If the user later resumes the task by selecting the launcher icon that began the task, the task comes to the foreground and resumes the activity at the top of the stack.
   	 * If the user presses the BACK key, the current activity is popped from the stack and destroyed. The previous activity in the stack is resumed. When an activity is destroyed, the system does not retain the activity's state.
   	 * Activities can be instantiated multiple times, even from other tasks.

	activity xml中配置
	android:launchMode	设置此activity与task之间关系
	standard(default)	acitivity 在启动他的task中建立一个新的实例,并将intent传递给它,此activity可以实例化多次,每一个实例可以在不同的task中,也可能在同一个task中具有多个此activity的实例
	singleTop		如果此activity的实例已经存在此task的top,系统将并不会产生一个新的activity实例,而是将intent通过onNewIntent()传递位于top的activity实例
				此activity实例可以实例化多次,每个acitivity实例属于不同的task,一个task可以拥有多个实例(仅限于activity实例,不在task的top位置)
	singleTask		系统在新task的root产生一个acitivity实例,若activity已经存在一个task,系统将调用已经存在task中activity实例的onNewIntent()方法,同时仅能有一个
				activity实例存在
	singleInstance	同singleTask,但是task中不会存在其他的acitvity实例.
Same as "singleTask", except that the system doesn't launch any other activities into the task holding the instance. The activity is always the single and only member of its task; any activities started by this one open in a separate task.
	代码中配置,设置intent的flag(flag会覆盖xml中launchMode的设置)
	* FLAG_ACTIVITY_NEW_TASK	singleTask
    	* FLAG_ACTIVITY_SINGLE_TOP	singleTop
	* FLAG_ACTIVITY_CLEAR_TOP	如果activity已经在currnt task中,所有在此activity实例之上的activity将被destory调用已经存在实例的onNewIntent().而非产生一个新的实例

115	startActivity(启动一个activity,无论是否在一个应用)
	(1)	Intent intent = new Intent(action);
		intent.setAction();
	或者
	(2)	ComponentName cm = new ComponentName("com.archermind.activitytask", "com.archermind.activitytask.Activity1");//pkg 是包名,cls 是包名加activity名
		intent.setComponent(cm);
	若用方法一,要在定义activity的manifest中添加fillter
	 <intent-filter>
            <action android:name="android.intent.action.TASK_ACTIVITY1" />
            <category android:name="android.intent.category.DEFAULT" />
        </intent-filter>

116	反射访问某个类的私有的成员变量

	     java.lang.reflect.Field field = AnimationDrawable.class.getDeclaredField("mCurFrame");
            field.setAccessible(true);//设置私有变量可以访问
            int curFrame = field.getInt(mAnimationDrawable);//mAnimationDrawable 为AnimationDrawable的某个实例
            if(curFrame == 17){
                field.setInt(mAnimationDrawable, 8);//设置mAnimationDrawable实例的,mCurFrame值为8;
            }


117	sqlite 表中插入当前时间	insert into tableName (time) values (datetime('now'));


118	android 应用获得自杀权限
	Android.mk 增加一行		LOCAL_CERTIFICATE := platform

       Manifest.xml 		<uses-permission android:name="android.permission.FORCE_STOP_PACKAGES" />

	代码中添加:
 	ActivityManager manager = (ActivityManager)getSystemService(ACTIVITY_SERVICE);
       manager.forceStopPackage(getPackageName());



120	slqite

	auto_vacuum	(查看pragma auto_vacuum)
	自动压缩空间,sqlite 默认不会自动压缩空间,
	修改值	命令	vacuum
			pragma auto_vacuum = 0|1;

	选择语句case
	case x
		when w1 then r1
		when w2 then r2
		when w3 then r3
		else r4
	end

123	常用apn设置
	<apns version="6">
<apn carrier="China Telecom net"
        mcc="460"
        mnc="03"
        apn="ctnet"
        server=""
        proxy="10.0.0.200"
        port="80"
        user=""
        password=""
        mmsc="null"
        mmsport=""
        type="default"
        current="1"
/>
<apn carrier="China Telecom mms"
        mcc="460"
        mnc="03"
        apn="ctwap"
        server=""
        proxy="10.0.0.200"
        port="80"
        user=""
        password=""
        mmsc="http://mmsc.vnet.mobi"
        mmsproxy="10.0.0.200"
        mmsport="80"
        type="mms"
        current="1"
/>
<apn carrier="China Unicom net"
        mcc="460"
        mnc="01"
        apn="3gnet"
        user=""
        server=""
        password=""
        mmsc="null"
        mmsport=""
        type="default"
        current="1"
                />
<apn carrier="China Unicom mms"
        mcc="460"
        mnc="01"
        apn="3gwap"
        server=""
        proxy="10.0.0.172"
        port="80"
        user=""
        password=""
        mmsc="http://mmsc.myuni.com.cn"
        mmsproxy="10.0.0.172"
        mmsport="80"
        type="mms"
        current="1"
                />
<apn carrier="China Mobile net"
        mcc="460"
        mnc="00"
        apn="cmnet"
        user=""
        server=""
        password=""
        mmsc="null"
        mmsport=""
        type="default"
        current="1"
                />
<apn carrier="China Mobile mms"
        mcc="460"
        mnc="00"
        apn="cmwap"
        server=""
        proxy="10.0.0.172"
        port="80"
        user=""
        password=""
        mmsc="http://mmsc.monternet.com"
        mmsproxy="10.0.0.172"
        mmsport="80"
        type="mms"
        current="1"
                />
<apn carrier="China Mobile net"
        mcc="460"
        mnc="02"
        apn="cmnet"
        user=""
        server=""
        password=""
        mmsc="null"
        mmsport=""
        type="default"
        current="1"
                />
<apn carrier="China Mobile mms"
        mcc="460"
        mnc="02"
        apn="cmwap"
        server=""
        proxy="10.0.0.172"
        port="80"
        user=""
        password=""
        mmsc="http://mmsc.monternet.com"
        mmsproxy="10.0.0.172"
        mmsport="80"
        type="mms"
        current="1"
                />
<apn carrier="China Mobile net"
        mcc="460"
        mnc="07"
        apn="cmnet"
        user=""
        server=""
        password=""
        mmsc="null"
        mmsport=""
        type="default"
        current="1"
                />
<apn carrier="China Mobile mms "
        mcc="460"
        mnc="07"
        apn="cmwap"
        server=""
        proxy="10.0.0.172"
        port="80"
        user=""
        password=""
        mmsc="http://mmsc.monternet.com"
        mmsproxy="10.0.0.172"
        mmsport="80"
        type="mms"
        current="1"
                />

</apns>



125
	在Android拨号系统中，有一套关于Telephony.SECRET_CODE的，拨号的时候以*#*#<code>#*#*的格式
	凡是以这样的格式拨号，系统会发出一个广播：
	action为：android.provider.Telephony.SECRET_CODE
	data为：android_secret_code：//code

	比如拨个 *#*#4636#*#*
	以下注册的BroadcastReceiver就会收到这个广播

        <receiver android:name="TestingSettingsBroadcastReceiver">
            <intent-filter>
                 <action android:name="android.provider.Telephony.SECRET_CODE" />
                 <data android:scheme="android_secret_code" android:host="4636" />
            </intent-filter>
       </receiver>


	import static android.provider.Telephony.Intents.SECRET_CODE_ACTION;

	public class PhoneSecretCodeTestReceiver extends BroadcastReceiver {

	    @Override
	    public void onReceive(Context context, Intent intent) {
		if(intent.getAction().equals(SECRET_CODE_ACTION));
		Intent i = new Intent().setComponent(new ComponentName("com.archemin.modetest","com.archemin.modetest.ModeTest"));
		i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		context.startActivity(i);
	    }

	}




145	android 引用framework资源(未公开的)
	代码中	com.android.internal.R.drawable.icon
	xml中	android:drawable="@*android:drawable/stat_sys_gps_on"

	android 引用framework资源(已公开的)
	代码中	com.android.R.drawable.icon
	xml中	android:drawable="@android:drawable/stat_sys_gps_on"


146 	短信编码
	7bit采用GSM字符集,8bit采用ASCII字符集,16bit采用Unicode字符集

147	限制textview字符长度
	 mNormal.setFilters(new InputFilter[]{new InputFilter.LengthFilter(10)});
	or	xml文件中
	android:maxLength = 10;

148	textview/edittext imeOptions
	actionDown
	actionGo
	actionSend
	添加自己的处理
	 mGo.setOnEditorActionListener(new OnEditorActionListener() {

            @Override
            public boolean onEditorAction(TextView arg0, int arg1, KeyEvent arg2) {
                switch(arg1){
                    case EditorInfo.IME_ACTION_GO:
                        Log.d(TAG, "action .... go ........");
                        break;
                    case EditorInfo.IME_ACTION_DONE:
                        Log.d(TAG, "action.....down.......");
                        break;
                    default:
                            break;

                }
                return false;
            }
        });
149	设置光标位置
	可能先获取requestFoucus();
	setSelection(0)

	设置EditText隐藏输入法
	mDown.setInputType(EditorInfo.TYPE_NULL);//EditorInfo.TYPE_NULL =0

	仅当点击edittext时,才会显示输入法
	getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);



150	设置inputmethod为默认输入法
	(1)app中,AndroidManifest.xml中,isDefault=true;设置当前输入法为默认输入法,
	当有多个输入法,设置此值时,系统会取第一个isDefault为true的输入法,作为默认输入法
	(2)通过Setting设置,默认输入法

	frameworks/base/packages/SettingsProvider/res/values/defaults.xml

	添加
	<string name="config_default_input_method" translatable="false">com.android.inputmthod.pinyin/.PingyinIME></string>


	frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java

	添加以下代码

	private void loadSecureSettings(SQLiteDatabase db){


		loadStringSetting(stmt,Settings.Secure.DEFAULT_INTPU_METHOD,R.string.config_default_input_method);

	}


153 	java值传递

		在java中实质只存在一种传递方式：即值传递。 而引用传递是对C/C++而言的。结论：

	　　对于基本类型，在方法体内对方法参数进行重新赋值，并不会改变原有变量的值。

	　　对于引用类型，在方法体内对方法参数进行重新赋予引用，并不会改变原有变量所持有的引用。

	　　方法体内对参数进行运算，不影响原有变量的值。

	　　方法体内对参数所指向对象的属性进行运算，将改变原有变量所指向对象的属性值。

	　　在JAVA中变量有以下两种：

	　　基本类型变量，包括char、byte、short、int、long、float、double、boolean。

	　　引用类型变量，包括类、接口、数组(基本类型数组和对象数组)。

	　　最后我们得出如下的结论：

	　　基本类型和基本类型变量被当作参数传递给方法时，是值传递。在方法实体中，无法给原变量重新赋值，也无法改变它的值。

	　　对象和引用型变量被当作参数传递给方法时，在方法实体中，无法给原变量重新赋值，但是可以改变它所指向对象的属性。

	(引用类型当做参数传递时,会自动生成原引用的一个副本b,指向原址,此时,改变引用所指向的对象,其实是修改b所指向的对象,所以原来的值不会改变,但是,改变b的属性,是改变的原对象的属性)


154	android获得当前语言

	string language = Locale.getDefault().getLanguage();//获取语言(小写)
	language = "zh"/"en"
	String loc = ActivityManagerNative.getDefault().getConfiguration().locale.getCountry();//获取Country(大写)
	loc = "CN"/"US"



155	sendStickyBroadcast(Intent intent)
	发送的广播长久存在,保留最后一次发送的广播,当后来者注册此intent的时候registerReceiver(BroadcastReceiver, IntentFilter),就会立即重新收到前面已经发送过的最后一次广播内容!若只想处理一次,可以通过removeStickyBroadcast(Inttent intent);将此广播移除
	发送sticky广播,要获得权限android.Manifest.permission#BROADCAST_STICKY

156	彻底删除raw_contacts
	String str = ContactsContract.RawContacts.CONTENT_URI.toString()+"?"+ContactsContract.CALLER_IS_SYNCADAPTER + "=true";
       this.getContentResolver().delete(Uri.parse(str), ContactsContract.RawContacts._ID+">0", null);


167	object equals()方法复写
	@Override
	public boolean equals(Object o) {
	     // Return true if the objects are identical.
	     // (This is just an optimization, not required for correctness.)
	     if (this == o) {
	       return true;
	     }

	     // Return false if the other object has the wrong type.
	     // This type may be an interface depending on the interface's specification.
	     if (!(o instanceof MyType)) {
	       return false;
	     }

	     // Cast to the appropriate type.
	     // This will succeed because of the instanceof, and lets us access private fields.
	     MyType lhs = (MyType) o;

	     // Check each field. Primitive fields, reference fields, and nullable reference
	     // fields are all treated differently.
	     return primitiveField == lhs.primitiveField &&
		     referenceField.equals(lhs.referenceField) &&
		     (nullableField == null ? lhs.nullableField == null
		                            : nullableField.equals(lhs.nullableField));
	}

	hashcode()复写
	 @Override
	public int hashCode() {
	     // Start with a non-zero constant.
	     int result = 17;

	     // Include a hash for each field.
	     result = 31 * result + (booleanField ? 1 : 0);	//boolean

	     result = 31 * result + byteField;			//byte		8bits
	     result = 31 * result + charField;			//char		16bits
	     result = 31 * result + shortField;			//short	16bits
	     result = 31 * result + intField;			//int		32bits

	     result = 31 * result + (int) (longField ^ (longField >>> 32));	//long 	64bits

	     result = 31 * result + Float.floatToIntBits(floatField);	//float	32bits

	     long doubleFieldBits = Double.doubleToLongBits(doubleField);		//64bits
	     result = 31 * result + (int) (doubleFieldBits ^ (doubleFieldBits >>> 32));//	>>>右移,高位以0补齐

	     result = 31 * result + Arrays.hashCode(arrayField);	//array

	     result = 31 * result + referenceField.hashCode();		//reference
	     result = 31 * result +
		 (nullableReferenceField == null ? 0
		                                 : nullableReferenceField.hashCode());

	     return result;
	}

	若不用hash key
	 @Override
	public int hashCode() {
	     throw new UnsupportedOperationException();
	}

	两个对象相等equals,则hashcode相同(java准则,在两个对象equals时,要保证其hashcode值相等);

	若两个对象hashcode相同,则两个对象equals不一定相等

	hashset 	原理,先比较hashcode,hashcode相同,再比较equals	by


	关于自动类型自动转换
	byte -> char -> int
	byte 有符号,char无符号,int 有符号位
	byte 转换成char	高位补符号位
		byte 转换成char	不希望符号位扩展	char cha = (char) (b & 0xff);
	char 转换成int		高位补零(乎略符号位,最高位为0则结果正确)
		char 转换成int要保留符号为可以用如下方法	int i = (short)char;
	宽字节转变成窄字节	直接截断低位,若要舍入用Math.round()方法




168	动态设置view的高度宽度
	LayoutParams lParams = mDeleteTopView.getLayoutParams();
       lParams.height = (int)getResources().getDimension(R.dimen.list_item_height);
       mDeleteTopView.setLayoutParams(lParams);


169	layout_weight		LinearLayout.LayoutParams	控件所占比例
	当控件layout_width=fill_parent,layout_weight 标明你的控件的优先级要尽可能大,但是大要有限度即full_parent,layout_weight 越小,占比例越大
	当控件layout_width=wrap_content,layout_weight 标明你的控件的优先要尽可能小,但是小要有限度即wrap_content
	当控件layout_width=0px,layout_weight ayout_weight 比例越大,占比例越大,当比例够大时,会将小比例的空间,挤小

170	android编译时,屏蔽Mms
		build/build/target/product/generic.mk
		build/build/target/product/core.mk

171	精确运算时,不要使用double,float
	要优先选择int,long,BigDecimal
	使用BigDecimal时,要使用BigDecimal(String)	例如 new BigDecimal("0.1") 而非使用 new BigDecimal(0.1)
	Constructs a new BigDecimal instance from the 64bit double val. The constructed big decimal is equivalent to the given double. For example, new BigDecimal(0.1) is equal to 0.1000000000000000055511151231257827021181583404541015625. This happens as 0.1 cannot be represented exactly in binary.

	private long number = 24 * 60 * 60 * 1000 * 1000;
		打印为:500654080	(int 数值计算,结果为int,计算完成之后才会转换成long类型,这会已经发生溢出)
	正确赋值为 private long number = 24l * 60 * 60 * 1000 * 1000;
		打印为:86400000000

172	条件表达式	expression ?　result1： result2
		表达式 result1,result2的类型最好一致,表达式结果类型即为二者的类型
		若result1 与result2类型不一致,
		(1)	如果一个操作数类型为T,T表示byte,short或char,而另一操作数为int类型的 常量 表达式,它的值可以用类型T表示的,那么条件表达式的类型就是T
		(2)	否则,将对操作数类型运用二进制数字提升,而条件表达式的类型就是第二个和第三个操作数被提升之后的类型

		a	65	A	97


173	复合表达式
		注意操作符两侧的类型应该相一致,
		short a = 34;
		int b;
		a +=b;	//直接计算,肯能值会截断
		a = a+ b;//编译失败需要加强制转换

174	打印char 数组
		char[] letters = {'a','b','c'};
		System.out.println(letters);		//abc	println()将char数组转化为string
		System.out.println("string " + letters);	//string @...		调用char[]的toString方法,因没有override故打印出来的是hashcode


175	try 	catch
	public class Indecisive {
		public static void main(String[] args) {
			System.out.println(decision());
		}
		static boolean decision() {
			try {
				return true;
			} finally {
				return false;
			}
		}
	}
	一条语句或一个语句块在它抛出了一个异常，或者对某个封闭型语句执行了一个break 或continue，或是象这个程序一样在方法中执行了一个return 时，将发生意外结束。它们之所以被称为意外结束，是因为它们阻止程序去按顺序执行下面的语句!
	要想不执行finally中语句,可以用System.exit(0);
	catch的异常必须是try语句块中抛出的异常;但是对任何语句,捕获Exception是可以的!


	public class HelloGoodbye1 {
		public static void main(String[] args) {
			System.out.println("Hello world");
			Runtime.getRuntime().addShutdownHook(
				new Thread() {
					public void run() {
					System.out.println("Goodbye world");
				}
			});
			System.exit(0);
		}
	}



176	android Dimention资源单位
	px 	pixels	表示屏幕实际的像素:如320*480	横向320个像素,纵向480个像素
	in	inches	表示英寸,是屏幕的物理尺寸,一英寸等于2.54cm	手机3.2英寸	手机屏幕对角线长为3.2英寸 即 3.2*2.54cm
	mm	millimetre	毫米,屏幕的物理尺寸
	pt 	表示一个点,屏幕的物理尺寸,大小为1英寸的1/72
	dp	与密度无关的像素,基于屏幕物理密度的抽象单位.密度可以理解为每英寸包含的像素个数,(单位dpi==>dots per inch),而1dp 相当于密度为160dpi的屏幕的一个点
		分辨率320*480	高度2英寸3英寸,则屏幕密度为160dpi	表示高度,宽度,位置等属性时,应尽量使用dp作为尺寸单位
	sp	与比例无关的像素,除了自适应屏幕密度外还会自适应用户设置的字体,设置字体应尽量使用sp作为尺寸单位


177	view onFocusChanged()	and 	onWindowFocusChanged()
	进入界面时,执行view的onWindowFocusChanged()	gain focus,若进入界面EditText,获得焦点,则先执行view的onFocusChanged(),再执行view的onWindowFocusChanged()

	离开界面时:执行view的onWindowFocusChanged()	lose focus,此时不会执行view的onFocusChanged()


178	同一个TextView,设置不同sytle字体
	 SpannableStringBuilder dateYear = new SpannableStringBuilder(date.toString().trim());
        //dateYear.setSpan(new AbsoluteSizeSpan(size), start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        dateYear.setSpan(new AbsoluteSizeSpan(largeTextSize), 0, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        dateYear.setSpan(new AbsoluteSizeSpan(smallTextSize), 3, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        dateYear.setSpan(new AbsoluteSizeSpan(largeTextSize), 4, 8, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        dateYear.setSpan(new AbsoluteSizeSpan(smallTextSize), 9, date.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        dateYear.setSpan(new StyleSpan(Typeface.BOLD), 0, dateYear.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);//Bold


179	根据资源名称获取资源id
	int id = mContext.getResources().getIdentifier(mContext.getPackageName()+":string/"+str, null, null);
       if(id>0){
       	Log.d(TAG, "        ; getString is : " + mContext.getResources().getString(id));
		String str = mContext.getResources().getString(id);
        }

180	设置背景透明
	android:background="#00000000"	@android:color/transparent
	或者
	view.getBackground().setAlpha();(0--255) 0 为透明


190	progressbar
	<ProgressBar
            android:id="@+id/search_text_seekbar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            style="?attr/android:progressBarStyleHorizontal"
            android:progress="0"
            android:max="100"
            android:layout_marginTop="@dimen/search_seekbar_margintop"
            android:paddingLeft="@dimen/search_seekbar_paddingleft"
            android:paddingRight="@dimen/search_seekbar_paddingright"/>


191	andorid 加密,支持MD5 or SHA-1

       MessageDigest md = MessageDigest.getInstance("SHA-1");
       byte[] hash = md.digest(res);

	或者
	android.security.Sha1MessageDigest
       android.security.Md5MessageDigest

192	  public boolean  onInterceptTouchEvent  (MotionEvent  ev)
	Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point.

	Using this function takes some care, as it has a fairly complicated interaction with View.onTouchEvent(MotionEvent), and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:

	   1. You will receive the down event here.
	   2. The down event will be handled either by a child of this view group, or given to your own onTouchEvent() method to handle; this means you should implement onTouchEvent() to return true, so you will continue to see the rest of the gesture (instead of looking for a parent view to handle it). Also, by returning true from onTouchEvent(), you will not receive any following events in onInterceptTouchEvent() and all touch processing must happen in onTouchEvent() like normal.
	   3. For as long as you return false from this function, each following event (up to and including the final up) will be delivered first here and then to the target's onTouchEvent().
	   4. If you return true from here, you will not receive any following events: the target view will receive the same event but with the action ACTION_CANCEL, and all further events will be delivered to your onTouchEvent() method and no longer appear here.

Parameters
ev 	The motion event being dispatched down the hierarchy.
Returns

    * Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here.
	1.回收到down事件
	2.
	3.return false;所有up事件,先到onInterceptTouchEvent,然后,进入目标view的onTouchEvent()
	4.return true;不会收到up事件,目标view的onTouchEvent()将会收到事件

193	自定义view,继承LinearLayout 或者RelativeLayout
	public class NumberPicker extends LinearLayout{
		    public NumberPicker(Context context, AttributeSet attrs) {
			super(context, attrs);
			setOrientation(VERTICAL);
			LayoutInflater inflater =
				(LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			inflater.inflate(R.layout.number_picker, this, true);//inflate xml attach all view to this

			InputFilter inputFilter = new NumberPickerInputFilter();
			mNumberInputFilter = new NumberRangeKeyListener();
			mIncrementButton = (NumberPickerButton) findViewById(R.id.increment);
			mIncrementButton.setOnClickListener(clickListener);
			mIncrementButton.setOnLongClickListener(longClickListener);
			mIncrementButton.setNumberPicker(this);

			mDecrementButton = (NumberPickerButton) findViewById(R.id.decrement);
			mDecrementButton.setOnClickListener(clickListener);
			mDecrementButton.setOnLongClickListener(longClickListener);
			mDecrementButton.setNumberPicker(this);

			mText = (EditText) findViewById(R.id.timepicker_input);
			mText.setOnFocusChangeListener(focusListener);
			mText.setFilters(new InputFilter[] {inputFilter});
			mText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
		}

	}

	number_picker.xml

      <merge xmlns:android="http://schemas.android.com/apk/res/android">

	    <NumberPickerButton android:id="@+id/increment"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:background="@drawable/timepicker_up_btn" />

	    <EditText android:id="@+id/timepicker_input"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:gravity="center"
		android:singleLine="true"
		style="?android:attr/textAppearanceLargeInverse"
		android:textColor="@android:color/primary_text_light"
		android:textSize="30sp"
		android:background="@drawable/timepicker_input" />

	    <NumberPickerButton android:id="@+id/decrement"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:background="@drawable/timepicker_down_btn" />

	</merge>

	注
	* <merge /> can only be used as the root tag of an XML layout
    	* When inflating a layout starting with a <merge />, you must specify a parent ViewGroup and you must set attachToRoot to true (see the documentation for inflate(int, android.view.ViewGroup, boolean) method)



194	在listview中,通常在newView的时候inflateLayout,布局文件根元素为CustomListView;
	CustomListView extends LinearLayout,在onFinishInflate()中获取元素

195	listview 拖动时有黑色的背景
	若背景为图片
	android:cacheColorHint="#00000000"
	若背景为某一颜色可以直接通过android:cacheColorHint="#00000000"指定背景颜色


196	button点击时字体颜色改变
	在xml下color.xml
	<resources>
   		<drawable name="black">#000</color>
    	       <drawable name="white">#FFF</drawable>
	</resources>

	在drawable下创建bt_text_color_selector.xml(默认黑色点击时为白色)
		<selector xmlns:android="http://schemas.android.com/apk/res/android">

		    <item android:state_pressed="true"
			android:color="@drawable/white"/>

		    <item android:state_focused="true" android:state_enabled="true"
			android:state_window_focused="true"
			android:color="@drawable/white"/>

		    <item
			 android:color="@android:color/black" />
		</selector>

	在布局文件中
	<Button
	android:textColor="@drawable/bt_text_color_selector"
	/>

197	HandlerThread(封装了Thread跟looper)
	private HandlerThread mHandlerThread = new HandlerThread("mcu-process");
	mHandlerThread.start();
       mHandler = new Handler(mHandlerThread.getLooper(), this);
	释放资源
	mHandlerThread.quit();

198
	private void startAnimation(boolean isAnimation,int preIndex,int pressIndex){
        Log.d(TAG, "preIndex is : " + preIndex + " ; pressIndex is : " + pressIndex);
        mMoveAnimation = null;
        mMoveAnimation = new TranslateAnimation(preIndex * mTextWidth,pressIndex * mTextWidth,(float)0,(float)0);
        mMoveAnimation.setInterpolator(new LinearInterpolator());
        mMoveAnimation.setAnimationListener(mAnimationListener);
        int interval = preIndex-pressIndex;
        interval = (interval >0 ) ? interval : (-interval);
        mMoveAnimation.setDuration(interval*TIME_DURATION);
        mMoveAnimation.setFillAfter(true);
        mFloatImage.startAnimation(mMoveAnimation);
    }


199	时间格式化
	private static String createName(long dateTaken) {
        return DateFormat.format("yyyy-MM-dd hh:mm:ss", dateTaken).toString();
    }

	import java.util.Formatter;
	import java.util.Locale;
	private String stringForTime(int timeMs) {
		StringBuilder               mFormatBuilder;
		Formatter                   mFormatter;
		mFormatBuilder = new StringBuilder();
		mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
		int totalSeconds = timeMs / 1000;
		int seconds = totalSeconds % 60;
		int minutes = (totalSeconds / 60) % 60;
		int hours = totalSeconds / 3600;
		mFormatBuilder.setLength(0);
		if (hours > 0) {
			return mFormatter.format("%d:%02d:%02d", hours, minutes, seconds).toString();<br>
		} else {
			return mFormatter.format("%02d:%02d", minutes, seconds).toString(); <br>
		}
	}


	if(DateFormat.is24HourFormat(mContext)){
       	DateFormat.format("kk:mm:ss", cal).toString();//24小时制
	}else{
		DateFormat.format("hh:mm:ss", cal).toString();//12小时制
	}


	time 格式化 seconds
	DateUtils.formatElapsedTime(timeElapsed)



200	在应用中禁用statusbar
	AndroidManifest.xml	添加
	<uses-permission android:name="android.permission.EXPAND_STATUS_BAR" />
       <uses-permission android:name="android.permission.STATUS_BAR" />
  	代码中添加

	    public static void disableStatusBar(Context context){
		Log.d(TAG, "disable StatusBar");
		if(mStatusBarManager == null){
		    mStatusBarManager = (StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
		}
		mStatusBarManager.disable(StatusBarManager.DISABLE_EXPAND);
	    }

	    public static void reEnabledStatusBar(Context context){
		Log.d(TAG, "enable StatusBar");
		if(mStatusBarManager == null){
		    mStatusBarManager = (StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
		}
		mStatusBarManager.disable(StatusBarManager.DISABLE_NONE);
	    }


201
	<TextView
			style="@style/Tips"
			android:text="@string/red"
        />
     <style name="Tips" parent="android:Widget.TextView">
        <item name="android:textSize">28sp</item>
        <item name="android:textStyle">normal</item>
        <item name="android:textColor">#ffe2e2e2</item>
        <item name="android:layout_width">@dimen/tips_text_width</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:singleLine">true</item>

    </style>


202 	限制editext输入字符为0-255
	Eiditext	xml中指定
	android:inputType=number;
	android:maxLength=3;

	代码中	继承TextWather
	    @Override
	    public void afterTextChanged(Editable s) {
            Log.d(TAG, "s is =====  > "  + s.toString());
            if(s.length()==1){
                char num = s.charAt(0);
                if(!ok(RGB_CHARACTERS[2], num)){
                    s.delete(0,1);
                }
            }else if(s.length()==2){
                for(int i=0;i<s.length();i++){
                    char num = s.charAt(i);
                    if(i==0){
                        if(!ok(RGB_CHARACTERS[2], num)){
                            s.delete(i, i+1);
                            i = i-1;
                        }
                    }else if(i==1){
                        if(!ok(RGB_CHARACTERS[2], num)){
                            s.delete(i, i+1);
                            i = i-1;
                        }
                    }
                }
            }else if(s.length()==3){
                int number = Integer.valueOf(s.toString());
                if(number>255){
                    s.delete(2, 3);
                }
            }else if(s.length()>3){
                s.delete(0, s.length());
                return;
            }


	    }


	    private static final char[][] RGB_CHARACTERS ={
            new char[] { '0', '1', '2' },
            new char[] { '0', '1', '2', '3', '4', '5'},
            new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' },
	    };

	    protected static boolean ok(char[] accept, char c) {
		for (int i = accept.length - 1; i >= 0; i--) {
		    if (accept[i] == c) {
		        return true;
		    }
		}
		return false;
	    }



203	屏蔽home键
	    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        // enable key test
        final int stretch = ViewGroup.LayoutParams.FILL_PARENT;
        // int flags = WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(stretch,
                stretch, WindowManager.LayoutParams.TYPE_KEYGUARD, 0,
                PixelFormat.OPAQUE);
        lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
        this.getWindow().setAttributes(lp);
        super.onWindowFocusChanged(hasFocus);
    }

204	点击EditText禁止弹出输入法
	EditText et=(EditText)findViewById(R.id.edit);
	et.setInputType(InputType.TYPE_DATETIME_VARIATION_NORMAL);


205
	 private DecimalFormat mFormat1;
	 private DecimalFormat mFormat2;
	 mFormat1 = new DecimalFormat("0000.000");//当前位不存在以0顶位
        mFormat2 = new DecimalFormat("####.###");//当前位不存在不现实
        double number = 342.3438342;
        System.out.println(mFormat1.format(number));//0342.344
        System.out.println(mFormat2.format(number));//342.344


206	WindowManagerService.java

	boolean mDrawWatermark = true;


	class Watermark {
        final String[] mTokens;
        final String mText;
        final Paint mTextPaint;
        final int mTextWidth;
        final int mTextHeight;
        final int mTextAscent;
        final int mTextDescent;
        final int mDeltaX;
        final int mDeltaY;

        Surface mSurface;
        int mLastDW;
        int mLastDH;
        boolean mDrawNeeded;

        Watermark(SurfaceSession session, String[] tokens) {
            final DisplayMetrics dm = new DisplayMetrics();
            mDisplay.getMetrics(dm);

            if (false) {
                Log.i(TAG, "*********************** WATERMARK");
                for (int i=0; i<tokens.length; i++) {
                    Log.i(TAG, "  TOKEN #" + i + ": " + tokens[i]);
                }
            }

            mTokens = tokens;
            /*
            StringBuilder builder = new StringBuilder(32);
            int len = mTokens[0].length();
            len = len & ~1;
            for (int i=0; i<len; i+=2) {
                int c1 = mTokens[0].charAt(i);
                int c2 = mTokens[0].charAt(i+1);
                if (c1 >= 'a' && c1 <= 'f') c1 = c1 - 'a' + 10;
                else if (c1 >= 'A' && c1 <= 'F') c1 = c1 - 'A' + 10;
                else c1 -= '0';
                if (c2 >= 'a' && c2 <= 'f') c2 = c2 - 'a' + 10;
                else if (c2 >= 'A' && c2 <= 'F') c2 = c2 - 'A' + 10;
                else c2 -= '0';
                builder.append((char)(255-((c1*16)+c2)));
            }
            mText = builder.toString();*/
            mText = mTokens[0];
            if (false) {
                Log.i(TAG, "Final text: " + mText);
            }

            //int fontSize = getPropertyInt(tokens, 1,
            //        TypedValue.COMPLEX_UNIT_DIP, 20, dm);
            int fontSize = 40;

            mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
            mTextPaint.setTextSize(fontSize);
            mTextPaint.setTypeface(Typeface.create(Typeface.SANS_SERIF, Typeface.BOLD));

            FontMetricsInt fm = mTextPaint.getFontMetricsInt();
            mTextWidth = (int)mTextPaint.measureText(mText);
            mTextAscent = fm.ascent;
            mTextDescent = fm.descent;
            mTextHeight = fm.descent - fm.ascent;

            mDeltaX = getPropertyInt(tokens, 2,
                    TypedValue.COMPLEX_UNIT_PX, mTextWidth*2, dm);
            mDeltaY = getPropertyInt(tokens, 3,
                    TypedValue.COMPLEX_UNIT_PX, mTextHeight*3, dm);
            int shadowColor = getPropertyInt(tokens, 4,
                    TypedValue.COMPLEX_UNIT_PX, 0xb0000000, dm);
            int color = getPropertyInt(tokens, 5,
                    TypedValue.COMPLEX_UNIT_PX, 0x60ffffff, dm);
            int shadowRadius = getPropertyInt(tokens, 6,
                    TypedValue.COMPLEX_UNIT_PX, 7, dm);
            int shadowDx = getPropertyInt(tokens, 8,
                    TypedValue.COMPLEX_UNIT_PX, 0, dm);
            int shadowDy = getPropertyInt(tokens, 9,
                    TypedValue.COMPLEX_UNIT_PX, 0, dm);

            mTextPaint.setColor(color);
            mTextPaint.setShadowLayer(shadowRadius, shadowDx, shadowDy, shadowColor);

            try {
                mSurface = new Surface(session, 0,
                        "WatermarkSurface", -1, 1, 1, PixelFormat.TRANSLUCENT, 0);
                mSurface.setLayer(TYPE_LAYER_MULTIPLIER*100);
                mSurface.setPosition(0, 0);
                mSurface.show();
            } catch (OutOfResourcesException e) {
            }
        }

        void positionSurface(int dw, int dh) {
            if (mLastDW != dw || mLastDH != dh) {
                mLastDW = dw;
                mLastDH = dh;
                mSurface.setSize(dw, dh);
                mDrawNeeded = true;
            }
        }

        void drawIfNeeded() {
            if (mDrawNeeded) {
                final int dw = mLastDW;
                final int dh = mLastDH;

                mDrawNeeded = false;
                //Rect dirty = new Rect(0, 0, dw, dh);
                int x = (dw - mTextWidth) / 2;
                int y = (dh - mTextHeight) / 2;
                Rect dirty = new Rect(x, y, mTextWidth, mTextHeight);
                Canvas c = null;
                try {
                    c = mSurface.lockCanvas(dirty);
                } catch (IllegalArgumentException e) {
                } catch (OutOfResourcesException e) {
                }
                if (c != null) {
                    c.drawText(mText, x, y, mTextPaint);
                    /*
                    int deltaX = mDeltaX;
                    int deltaY = mDeltaY;

                    // deltaX shouldn't be close to a round fraction of our
                    // x step, or else things will line up too much.
                    int div = (dw+mTextWidth)/deltaX;
                    int rem = (dw+mTextWidth) - (div*deltaX);
                    int qdelta = deltaX/4;
                    if (rem < qdelta || rem > (deltaX-qdelta)) {
                        deltaX += deltaX/3;
                    }

                    int y = -mTextHeight;
                    int x = -mTextWidth;
                    while (y < (dh+mTextHeight)) {
                        c.drawText(mText, x, y, mTextPaint);
                        x += deltaX;
                        if (x >= dw) {
                            x -= (dw+mTextWidth);
                            y += deltaY;
                        }
                    }*/
                    mSurface.unlockCanvasAndPost(c);
                }
            }
        }
    }

    void createWatermark() {
        if (mWatermark != null) {
            return;
        }

        if (mDrawWatermark) {
            String[] toks ={"Only For Test"};
            mWatermark = new Watermark(mFxSession, toks);
        }
       /*
        File file = new File("/system/etc/setup.conf");
        FileInputStream in = null;
        try {
            in = new FileInputStream(file);
            DataInputStream ind = new DataInputStream(in);
            String line = ind.readLine();
            if (line != null) {
                String[] toks = line.split("%");
                if (toks != null && toks.length > 0) {
                    mWatermark = new Watermark(mFxSession, toks);
                }
            }
        } catch (FileNotFoundException e) {
        } catch (IOException e) {
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
        }*/




    }





	207	将/data写入随机数，每次写1M，写930次！
	cd /data
	busybox dd if=/dev/urandom of=test bs=1M count=930

	208	int转化成十六进制
	public static String format(int n){
		String str=Integer.toHexString(n);
		int l=str.length();
		if(l==1)
			return "0"+str;
		else
			return str.substring(l-2,l);
	}



	208隐藏显示statusbar
    public static void disableStatusBar(Context context){
        Log.d(TAG, "disable StatusBar");
        if(mStatusBarManager == null){
            mStatusBarManager = (StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
        }
        mStatusBarManager.disable(StatusBarManager.DISABLE_EXPAND);
    }

    public static void reEnabledStatusBar(Context context){
        Log.d(TAG, "enable StatusBar");
        if(mStatusBarManager == null){
            mStatusBarManager = (StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
        }
        mStatusBarManager.disable(StatusBarManager.DISABLE_NONE);
    }

	全屏非全屏切换
	if (isFulllScreen) {//设置全屏
		WindowManager.LayoutParams params = getWindow().getAttributes();
		params.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN;
		getWindow().setAttributes(params);
		getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
	} else {//设置非全屏
		WindowManager.LayoutParams params = getWindow().getAttributes();
		params.flags &= (~WindowManager.LayoutParams.FLAG_FULLSCREEN);
		getWindow().setAttributes(params);
		getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
	}


	209	常用颜色
	<color name="white">#ffffffff</color>
	<color name="black">#ff000000</color>
	<color name="transparent">#00000000</color>



	210 CountDownLatch 用于处理控制多线程。。。
	（1）一个问题分成1+N部分，N中每一部需要在一个单独的线程中完成，等N部分都处理完之后，1问题才能执行。
		import java.util.concurrent.CountDownLatch;
		import java.lang.InterruptedException;
		class Driver{

		    public static final int N = 10;
		    public static  void main(String args[]) {
			CountDownLatch doneSignal = new CountDownLatch(N);

			for (int i = 0; i < N; ++i) // create and start threads
			    new Thread(new Worker(doneSignal, i)).start();

			try{
			    doneSignal.await();           // wait for all to finish

			}catch(InterruptedException e){

			}
			doSomethingElse();
		    }

		    public static void doSomethingElse(){
			System.out.println("do something else ....");
		    }
		}

		class Worker implements Runnable {
		       private final CountDownLatch doneSignal;
		       private final int i;

		       Worker(CountDownLatch doneSignal,int i) {

			   this.doneSignal = doneSignal;
			   this.i = i;
		      }
		      public void run() {
			  doWork(i);
			  doneSignal.countDown();
		     }

		      void doWork(int i) {
			  System.out.println("do some work..."+ i +"....");
		      }
		}

	（2）Sample usage: Here is a pair of classes in which a group of worker threads use two countdown latches:

    	The first is a start signal that prevents any worker from proceeding until the driver is ready for them to proceed;
    	The second is a completion signal that allows the driver to wait until all workers have completed.

	import java.util.concurrent.CountDownLatch;
	import java.lang.InterruptedException;
	class Driver{

	    public static final int N = 10;
	    public static  void main(String args[]) {
		CountDownLatch doneSignal = new CountDownLatch(N);

		for (int i = 0; i < N; ++i) // create and start threads
		    new Thread(new Worker(doneSignal, i)).start();

		try{
		    doneSignal.await();           // wait for all to finish

		}catch(InterruptedException e){

		}
		doSomethingElse();
	    }

	    public static void doSomethingElse(){
		System.out.println("do something else ....");
	    }
	}

	class Worker implements Runnable {
	       private final CountDownLatch doneSignal;
	       private final int i;

	       Worker(CountDownLatch doneSignal,int i) {

		   this.doneSignal = doneSignal;
		   this.i = i;
	      }
	      public void run() {
		  doWork(i);
		  doneSignal.countDown();
	     }

	      void doWork(int i) {
		  System.out.println("do some work..."+ i +"....");
	      }
	}

	211 RaidoButton 显示在右侧
	android:button="@null"
 	android:drawableRight="@android:drawable/btn_radio"


	212
	图片居中显示，增加控件的点击区域
	（1）
	<ImageView
		android:layout_width="200dip"
		android:id="@+id/imageview"
		android:layout_height="200dip"
		android:src="@drawable/image_selector"
		android:background="@android:color/translate"
        />

	image_selector.xml定义如下
	<selector xmlns:android="http://schemas.android.com/apk/res/android">
	    <item android:state_pressed="true"
		android:drawable="@drawable/insert_image_pressed" />
	    <item android:state_enabled="true"
		android:drawable="@drawable/insert_image_normal" />
	    <item
		 android:drawable="@drawable/insert_image_normal" />
	</selector>

	insert_image_pressed.xml
	<?xml version="1.0" encoding="utf-8"?>

	<inset xmlns:android="http://schemas.android.com/apk/res/android"
	    android:drawable="@drawable/icon_pressed"
	    android:insetTop="10dip"
	    android:insetRight="10dip"
	    android:insetBottom="10dip"
	    android:insetLeft="10dip" />

	insert_image_normal.xml
	<?xml version="1.0" encoding="utf-8"?>

	<inset xmlns:android="http://schemas.android.com/apk/res/android"
	    android:drawable="@drawable/icon_normal"
	    android:insetTop="10dip"
	    android:insetRight="10dip"
	    android:insetBottom="10dip"
	    android:insetLeft="10dip" />
	（2）
	<ImageView
        android:layout_width="200dip"
        android:id="@+id/imageview2"
        android:layout_height="200dip"
        android:scaleType="center"
        android:src="@drawable/image_selector"
        android:background="@android:color/transparent"
        />


	213	程序中捕获crash，并记输入crash信息，仿照android系统crash捕获机制
	import java.lang.Thread.UncaughtExceptionHandler;
	import java.lang.Thread;
	在onCreate()中实现	Thread.setDefaultUncaughtExceptionHandler(new DefaultCrashHandler(this));
	类DefaultCrashHandler实现如下：

	private class DefaultCrashHandler implements UncaughtExceptionHandler{

        private Context act = null;

        public DefaultCrashHandler(Context act) {
           this.act = act;
        }

           @Override
           public void uncaughtException(Thread thread, Throwable ex) {
               StringWriter sw = new StringWriter();
               ex.printStackTrace(new PrintWriter(sw));
               Log.d(TAG, sw.toString());
               //printlnCrashInfo(new CrashInfo(ex));
              try {

                  Thread.sleep(500);

              } catch (InterruptedException e) {

              } finally {
                  // Try everything to make sure this process goes away.

              }

              System.exit(-1);

        }

    }

	参考代码	base/core/java/com/android/internal/os/RuntimeInit.java
			base/core/java/android/app/ApplicationErrorReport.java&CrashInfo

	213 	back键模拟home键
	public boolean onKeyDown(int keyCode, KeyEvent event) {
	     if (keyCode == KeyEvent.KEYCODE_BACK) {
	       Intent intent = new Intent(Intent.ACTION_MAIN);
              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
              intent.addCategory(Intent.CATEGORY_HOME);
              startActivity(intent);
              return true;
         }
          return super.onKeyDown(keyCode, event);
      }



	214
	一、Bitmap转Drawable


		Bitmap bm=xxx; //xxx根据你的情况获取

		BitmapDrawable bd=new BitmapDrawable(bm);
		因为BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。

	二、 Drawable转Bitmap

		转成Bitmap对象后，可以将Drawable对象通过Android的SK库存成一个字节输出流，最终还可以保存成为jpg和png的文件。
		Drawable d=xxx; //xxx根据自己的情况获取drawable

		BitmapDrawable bd = (BitmapDrawable) d;

		Bitmap bm = bd.getBitmap();
		最终bm就是我们需要的Bitmap对象了。



		// 从资源中获取Bitmap
		public static Bitmap getBitmapFromResources(Activity act, int resId) {
		Resources res = act.getResources();
		return BitmapFactory.decodeResource(res, resId);
		}

		// byte[] → Bitmap
		public static Bitmap convertBytes2Bimap(byte[] b) {
		if (b.length == 0) {
		return null;
		}
		return BitmapFactory.decodeByteArray(b, 0, b.length);
		}

		// Bitmap → byte[]
		public static byte[] convertBitmap2Bytes(Bitmap bm) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		bm.compress(Bitmap.CompressFormat.PNG, 100, baos);
		return baos.toByteArray();
		}

		// 1)Drawable → Bitmap
		public static Bitmap convertDrawable2BitmapByCanvas(Drawable drawable) {
		Bitmap bitmap = Bitmap
		.createBitmap(
		drawable.getIntrinsicWidth(),
		drawable.getIntrinsicHeight(),
		drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888
		: Bitmap.Config.RGB_565);
		Canvas canvas = new Canvas(bitmap);
		// canvas.setBitmap(bitmap);
		drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),
		drawable.getIntrinsicHeight());
		drawable.draw(canvas);
		return bitmap;
		}

		// 2)Drawable → Bitmap
		public static Bitmap convertDrawable2BitmapSimple(Drawable drawable){
		BitmapDrawable bd = (BitmapDrawable) drawable;
		return bd.getBitmap();
		}

		// Bitmap → Drawable
		public static Drawable convertBitmap2Drawable(Bitmap bitmap) {
		BitmapDrawable bd = new BitmapDrawable(bitmap);
		// 因为BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。
		return bd;
		}

	215.RGB565（2byte）转换成java RGB565(3byte)	取高位并线性补偿
	public int bytesToColor(byte low,byte high){
       	int red = high & 0xf8 | high & 0xf8 >> 3 & 0x07;//linear Compensation
       	int green = (((high & 0x07) << 3 | (low & 0xe0) >>5) << 2 ) | ((low & 0xe0) >> 5 & 0x03);
       	int blue = (low & 0x1f) << 3 | low & 0x07;
       	//return (high & 0xf8) << 16 | ((high & 0x07) << 3 | (low & 0xe0) >>5) << 10 | (low & 0x1f)<<3;
       	return red << 16 | green << 8 | blue;
	}

	216	Service 中创建Systemdialog
	            mAlertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
		xml文件中添加permission
		    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>


	217	java byte 转化成bit
	public static String byteToBit(byte b) {
		return ""
       		+ (byte) ((b >> 7) & 0x1) + (byte) ((b >> 6) & 0x1)
              	+ (byte) ((b >> 5) & 0x1) + (byte) ((b >> 4) & 0x1)
      			+ (byte) ((b >> 3) & 0x1) + (byte) ((b >> 2) & 0x1)
       		+ (byte) ((b >> 1) & 0x1) + (byte) ((b >> 0) & 0x1);
     }


	218	修改textsize会改变layout
	layout添加	android:gravity="center"属性

	219	Dialog 去除titlebar
	requestWindowFeature(Window.FEATURE_NO_TITLE);


	220	显示隐藏statusbar
    private void setFullScreen(){
        isFullScreen = true;
        WindowManager.LayoutParams params = getWindow().getAttributes();
        params.flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN;
        getWindow().setAttributes(params);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
    }

    private void setNotFullScreen(){
        isFullScreen = false;
        WindowManager.LayoutParams params = getWindow().getAttributes();
        params.flags &= (~WindowManager.LayoutParams.FLAG_FULLSCREEN);
        getWindow().setAttributes(params);
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
    }

	221 Activity.startActivityForResult(Intent intent, int requestCode);
	(1)	requestCode < 0;不需要返回值等同于 	Acivity.startActivity(Inttent intent);
	(2)	requsetCode >= 0;需要返回值	if the activity you are launching uses the singleTask launch mode,
		it will not run in your task and thus you will immediately receive a cancel result（收不到activity返回结果，仅能收到一个cancel结果）
       （3）	在onCreate()或onResume（）中调用，则会等到返回结果时，才显示当前acitivity


	222 object/String格式化
	String.format(String format, Object object)


	234 password
	EditText.setInputType(int);
	EditText.setTransformationMethod(PasswordTransformationMethod.getInstance());
	or
	android:password="true"
	android:inputTypt="number"


	235	返回键不destory activity，行为类似home键
	首先，当我们案back钮时activity会被毁灭掉(android内置) 因此这次要说明的是，若何back钮不被毁灭，做法即是改写Activity中的onKeyDown()，然后拦截 KeyEvent.KEYCODE_BACK，唿叫moveTaskToBack(true);来实现。

@Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
            if(keyCode == KeyEvent.KEYCODE_BACK){
                    moveTaskToBack(true);
                return true;
            }
            return super.onKeyDown(keyCode, event);
        }



	236
	Affinity 应用于两种情况
		(1)launch activity with the FLAG_ACTIVITY_NEW_TASK  flag
			FLAG_ACTIVITY_NEW_TASK 新起一个task，若已经有相同Affinity属性的task存在，则将其放进已经存在的task中
		(2)activity has its allowTaskReparenting attribute set to "true"


	237	模拟key事件
	public void sendDownUpKeyEvents(int keyEventCode) {
        long eventTime = SystemClock.uptimeMillis();
        Handler handler = mTargetView.getHandler();
        handler.sendMessage(handler.obtainMessage(ViewRoot.DISPATCH_KEY_FROM_IME,
                new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyEventCode, 0, 0, 0, 0,
                    KeyEvent.FLAG_SOFT_KEYBOARD|KeyEvent.FLAG_KEEP_TOUCH_MODE)));
        handler.sendMessage(handler.obtainMessage(ViewRoot.DISPATCH_KEY_FROM_IME,
                new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, keyEventCode, 0, 0, 0, 0,
                        KeyEvent.FLAG_SOFT_KEYBOARD|KeyEvent.FLAG_KEEP_TOUCH_MODE)));
    }


	238
	进行系统属性设置的程序也必须有system或root权限
	JAVA
	import android.os.SystemProperties;

	SystemProperties.set("persist.sys.language", zone.getID());
	String lang= SystemProperties.get("persist.sys.language");

	C

	#include <cutils/properties.h>

	property_set("persist.sys.language", "zh");
	property_get("persist.sys.language", propLang, "en");
	在adb shell可以通过以下的命名读取和修改

	#getprop  persist.sys.language
	#setprop  persist.sys.language  zh 	//data/property/persist.sys.language 文件


	239	应用中执行重启reboot
	           PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
	           pm.reboot("");//reboot（"recovery"）执行不同流程
		AndroidManifest.xml 中添加权限
		<uses-permission android:name="android.permission.REBOOT" />

	240	动态的关闭开放组件
	为什么要关闭组件？
	在用到组件时，有时候我们可能暂时性的不使用组件，但又不想把组件kill掉，比如创建了一个broadcastReceiver广播监听器，用来想监听第一次开机启动后获得系统的许多相关信息，并保存在文件中，这样以后每次开机启动就不需要再去启动该服务了，也就是说如果没有把receiver关闭掉，就算是不做数据处理，但程序却还一直在后台运行会消耗电量和内存，这时候就需要把这个receiver给关闭掉。

	如何关闭组件？
	关闭组件其实并不难，只要创建packageManager对象和ComponentName对象，并调用packageManager对象的setComponentEnabledSetting方法。方法描述如下：
	1 setComponentEnabledSetting(ComponentName componentName, int newState, int flags)

	componentName：组件名称
	newState：组件新的状态，可以设置三个值，分别是如下：
	不可用状态：COMPONENT_ENABLED_STATE_DISABLED
	可用状态：COMPONENT_ENABLED_STATE_ENABLED
	默认状态：COMPONENT_ENABLED_STATE_DEFAULT
	flags:行为标签，值可以是DONT_KILL_APP或者0。

	 pm.setComponentEnabledSetting(comptName,
        	PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
        	PackageManager.DONT_KILL_APP);
        Toast.makeText(this, "组件已启用", Toast.LENGTH_LONG).show();

        pm.setComponentEnabledSetting(comptName,
        	PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
              PackageManager.DONT_KILL_APP);
        Toast.makeText(this, "组件已禁用", Toast.LENGTH_LONG).show();



	241 TypedArray
	自定义view中使用
	TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.CustomView,R.attr.customViewStyle, 0);

	（1）attrs.xml
		    <declare-styleable name="CustomView">
			<attr name="bg" format="reference"  />
			<attr name="text" format="reference"  />
		    </declare-styleable>


	（2）tyles.xml
		    <style name="CustomViewStyle">
			<item name="bg">@android:color/white</item>
			<item name="text">@string/custom_text</item>
		    </style>

	（3）//首先，在application中把主题设为我们的自定义的主题，已经是自定义的就pass这步。
		<application
			android:theme="@style/Theme"
	 
	//然后.要在attrs.xml里自定义CustomViewStyle属性
		<attr name="customViewStyle" format="reference" />

	//最后，在styles.xml中自定义的自定义主题中加入这个自定义的属性来引用我们自定义的style..
	        <style name="Theme" parent="@android:style/Theme.Black">
          		<item name="customViewStyle">@style/CustomViewStyle</item>
    		</style>

	（4）所以最终的attrs.xml为：
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
	    <declare-styleable name="CustomView">
		<attr name="customViewStyle" format="reference" />
		<attr name="bg" format="reference"  />
		<attr name="text" format="reference"  />
	    </declare-styleable>

	</resources>
	（5）最终styles.xml为：
	<resources xmlns:android="http://schemas.android.com/apk/res/android">
	    <style name="CustomViewStyle">
		<item name="bg">@android:color/white</item>
		<item name="text">@string/custom_text</item>
	    </style>

	    <style name="Theme" parent="@android:style/Theme.Black">
		  <item name="customViewStyle">@style/CustomViewStyle</item>
	    </style>

	</resources>


	241.dialog监听back键
	dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {

                       @Override
                       public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                               if(keyCode == KeyEvent.KEYCODE_BACK){
                                       if(mListener!=null){
                                               mListener.onPairedDevicesDialogBackPressed();
                                       }
                               }
                               return false;
                       }
               });



	242.配置默认时区	RuntimeInit.java

	private static final void commonInit() {
        if (Config.LOGV) Slog.d(TAG, "Entered RuntimeInit!");

        /* set default handler; this applies to all threads in the VM */
        Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());

        int hasQwerty = getQwertyKeyboard();

        if (Config.LOGV) Slog.d(TAG, ">>>>> qwerty keyboard = " + hasQwerty);
        if (hasQwerty == 1) {
            System.setProperty("qwerty", "1");
        }

        /*
         * Install a TimezoneGetter subclass for ZoneInfo.db
         */
        TimezoneGetter.setInstance(new TimezoneGetter() {
            @Override
            public String getId() {
                //add by kai.liu for init timezone at 2012-05-08 start
                String  zoneInfo = SystemProperties.get("persist.sys.timezone");
                Slog.i(TAG, "zoneinfo is " + zoneInfo);
                if (zoneInfo == null || zoneInfo.length() == 0){
                    String zonedefaultinfo = SystemProperties.get("ro.default.timezone");
                    if (zonedefaultinfo != null && zonedefaultinfo.length() > 0){
                        SystemProperties.set("persist.sys.timezone", zonedefaultinfo);
                        Slog.i(TAG, "zonedefaultinfo is " + zonedefaultinfo);
                      }
                 }
                Slog.i(TAG, "persist.sys.timezone is " + SystemProperties.get("persist.sys.timezone"));
              //add by kai.liu for init timezone at 2012-05-08 end
                return SystemProperties.get("persist.sys.timezone");
            }
        });
        TimeZone.setDefault(null);

        /*

	设置系统prop
	./build/target/board/generic/system.prop中增加下面字段(假设改为上海时区)
       ro.default.timezone=Asia/Shanghai



	243.位图Bitmap
	色彩深度又叫色彩位数，即位图中要用多少个二进制位来表示每个点的颜色，是分辨率的一个重要指标。常用有1位（单色），2位（4色，CGA），4位（16色，VGA），8位（256色），16位（增强色），24位和32位（真彩色）等。色深16位以上的位图还可以根据其中分别表示RGB三原色或CMYK四原色（有的还包括Alpha通道）的位数进一步分类，如16位位图图片还可分为R5G6B5，R5G5B5X1（有1位不携带信息），R5G5B5A1，R4G4B4A4等等
	位图采用RGB颜色模型，是一个二维的像素矩阵的方法显示和存储的图象，矩阵中的每个元素代表一个像素。真彩图像为24位图，即包含多达224种颜色。真彩图片的特点：它没有调色板，直接用元素来表示像素的颜色值，每个元素(R,G,B)包含一个字节的红(R)色分量，一个字节的绿(G)色分量，和一个字节的蓝(B)色分量。可见真彩图片颜色细腻，但数据量巨大，一帧1024×768分辨率的真彩图片要占用空间：1024×768×3B＝2.25MB。256色图为8位图，它由调色板和索引数据组成。调色板保存256种颜色的色彩分量值。索引数据的每个元素由8位组成，该8位的值为调色板的上对应颜色的索引位置。256色图的特点：只能表示256种颜色，但数据量小，一帧1024×768分辨率256色图只占用空间：1024×768＋256×3=768.8kB。



	244.app非全屏
	在布局文件layout中设置全屏但是显示仍非全屏
	AndroidManifest.xml文件中没有设置android:minSdkVersion或者android:minSdkVersion<=3(3对应是SDK1.5)
	修改方法：
	(1)	android:minSdkVersion值大于3,设置为4(sdk 1.6即可)
	android从1.6和更高，Google为了方便开发者对于各种分辨率机型的移植而增加了自动适配的功能，若没有设置此属性其值为1
	<uses-sdk android:minSdkVersion="4" />
	(2)	在AndroidManifest中添加
	<supports-screens android:smallScreens="true"
        android:normalScreens="true" android:largeScreens="true"
        android:anyDensity="true" />


	245 oneway interface
		In early betas, the Android IPC was strictly synchronous. This means that service invocations had to wait for the return value of the remote method to arrive back to the caller. This is generally an advantage because the caller can be sure that the called service received the invocation by the time the remote method returns. In some cases, however, this causes the caller to wait unnecessarily. If synchronicity is not required and the method has no return value, oneway AIDL interfaces may be used.

	Oneway methods are specified by addind the oneway keyword to the AIDL interface definition.

	package com.elfylin;
	oneway interface IMyServiceOneway {
	    String getValue();
	}


	246 ImageView
	当同时设置background和src属性时，如果src图片比背景小，则默认会把src拉伸
	设置android:scaleType=center 时，src会居中显示


	247 修改Android系统默认字体大小
	frameworks/base/core/java/android/content/res/Configuration.java

	code
	 public void setToDefaults() {
       	fontScale = 1.1f;//修改此值	setting中 0.75f 1.0f(默认) 1.25f
	}


	248	DecimaFormat java.text.DecimalFormat(跟本地化有关函数)
		四舍五入格式化问题
		DecimalFormat f = new DecimalFormat("#,##0.00");
		f.setRoundingMode(RoundingMode.HALF_UP);

		double d = 1.125;
		System.out.println(f.format(d)); // 输出 1.13

		d = 1.135;
		System.out.println(f.format(d)); // 输出 1.14

		时间相关的格式化参考SimpleDateFormat

	249	格式化数字
		String str = String.format(Locale.US,"%.2f",freq);
		若果freq是整数则以上等价于String str = String.format(Locale.US,"%s",freq);
		String str = String.format("%.2f",freq);等同与DecimaFormat


	250 屏幕密度
	 	DisplayMetrics metric = new DisplayMetrics();
        	getWindowManager().getDefaultDisplay().getMetrics(metric);
        	int width = metric.widthPixels;  // 屏幕宽度（像素）
        	int height = metric.heightPixels;  // 屏幕高度（像素）
        	float density = metric.density;  // 屏幕密度（0.75 / 1.0 / 1.5）
        	int densityDpi = metric.densityDpi;  // 屏幕密度DPI（120 / 160 / 240）




	251 drawText muti line
		之前遇到这个问题的时候想到了好多好多的办法
		1：把字符串截取成字符串数组 然后一行一行 drawText（） 发现好麻烦
		2：试试能不能加\n最终以失败告终
		3：终于找到了合适的方法
		其实，android中是有提供实现绘制字符串换行的方式的
		TextPaint
		TextPaint textPaint = new TextPaint();
		textPaint.setColor(Color.WHITE);
		textPaint.setAntiAlias(true);
		textPaint.setTextSize(20.0F);
		String aboutTheGame = "关于本游戏：本游戏是做测试用的，这些文字也是，都不是瞎写的！ ";
		/** * aboutTheGame ：要 绘制 的 字符串 ,textPaint(TextPaint 类型)设置了字符串格式及属性 的画笔,240为设置 画多宽后 换行，后面的参数是对齐方式... */
		StaticLayout layout = new StaticLayout(aboutTheGame,textPaint,240,Alignment.ALIGN_NORMAL,1.0F,0.0F,true);
		//从 (20,80)的位置开始绘制
		canvas.translate(20,80);
		layout.draw(canvas);


	252 java中进行2、8、16、10进制之间的转换
		java中进行二进制，八进制，十六进制，十进制间进行相互转换

		十进制转成十六进制：
		Integer.toHexString(int i)
		十进制转成八进制
		Integer.toOctalString(int i)
		十进制转成二进制
		Integer.toBinaryString(int i)
		十六进制转成十进制
		Integer.valueOf("FFFF",16).toString()
		八进制转成十进制
		Integer.valueOf("876",8).toString()
		二进制转十进制
		Integer.valueOf("0101",2).toString()

		java.lang.Integer类可以直接将2,8,16进制直接转换为10进制
		Integer.parseInt(String s, int radix)

		使用第二个参数指定的基数，将字符串参数解析为有符号的整数。

		examples
		parseInt("0", 10) returns 0
		parseInt("473", 10) returns 473
		parseInt("-0", 10) returns 0
		parseInt("-FF", 16) returns -255
		parseInt("1100110", 2) returns 102
		parseInt("2147483647", 10 ) returns 2147483647
		parseInt("-2147483648", 10 ) returns -2147483648
		parseInt("2147483648", 10 ) throws a NumberFormatException
		parseInt("99", 8 ) throws a NumberFormatException
		parseInt("Kona", 10 ) throws a NumberFormatException
		parseInt("Kona", 27 ) returns 411787

		进制转换如何写（二，八，十六）不用算法
		Integer.toBinaryString
		Integer.toOctalString
		Integer.toHexString

	253 android.provider.Telephony.SECRET_CODE 拨号盘启动activity
		AndroidManifest.xml中定义
		<receiver android:name="TestingSettingsBroadcastReceiver">
		    <intent-filter>
		         <action android:name="android.provider.Telephony.SECRET_CODE" />
		         <data android:scheme="android_secret_code" android:host="4636" />
		    </intent-filter>
	       </receiver>
		拨号盘中输入*#*#4636#*#*

		TestingSettingsBroadcastReceiver.java
		public class TestingSettingsBroadcastReceiver extends BroadcastReceiver {

		    public TestingSettingsBroadcastReceiver() {
		    }

		    @Override
		    public void onReceive(Context context, Intent intent) {
			if (intent.getAction().equals(SECRET_CODE_ACTION)) {
			    Intent i = new Intent(Intent.ACTION_MAIN);
			    i.setClass(context, TestingSettings.class);
			    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			    context.startActivity(i);
			}
		    }
		}



    254 android LineraLayout 分隔符 动态隐藏
        android:divider="@drawable/divider"
        android:showDividers="middle"

    divider.xml
    <?xml version= "1.0"  encoding= "utf-8" ?>
    <shape xmlns:android= "http://schemas.android.com/apk/res/android"
        android:shape= "rectangle" >
        <size  android:width = "@dimen/spacing_medium"
               android:height = "@dimen/spacing_medium"  />
        <solid android:color= "@android:color/transparent"  />
     </shape>


    255 AndroidManifest.xml中android:configChanges的简介

        程序在运行时，一些设备的配置可能会改变，如：横竖屏的切换、键盘的可用性等，这样的事情一发生，Activity会重新启动，其中的过程是：在销毁之前会先 called  onSaveInstanceState()去保存你应用中的一些数据，然后called onDestroy()，最后才去called onCreate()或onRestoreInstanceState()方法去重新启动Activity。

        当指定的属性发生变化时，不会去重新启动Activity，而是通知程序去调用 onConfigurationChanged()函数 例如：在进行横竖屏的切换时，会重新启动Activity，而定义了这个属性，就不会重新启动Activity了，而是去调用 onConfigurationChanged()函数

        可以设置多个属性，中间用｜隔开
        "mcc"        国际移动用户识别码所属国家代号是改变了-----  sim被侦测到了，去更新mcc    mcc是移动用户所属国家代号
        "mnc"        国际移动用户识别码的移动网号码是改变了------ sim被侦测到了，去更新mnc    MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网
        "locale"        地址改变了-----用户选择了一个新的语言会显示出来
        "touchscreen"        触摸屏是改变了------通常是不会发生的
        "keyboard"        键盘发生了改变----例如用户用了外部的键盘
        "keyboardHidden"        键盘的可用性发生了改变
        "navigation"        导航发生了变化-----通常也不会发生
        "screenLayout"        屏幕的显示发生了变化------不同的显示被激活
        "fontScale"        字体比例发生了变化----选择了不同的全局字体
        "uiMode"        用户的模式发生了变化
        "orientation"        屏幕方向改变了
        "screenSize"        屏幕大小改变了
        "smallestScreenSize"        屏幕的物理大小改变了，如：连接到一个外部的屏幕上

        具体设置如下代码所示：
        <activity
            android:name="com.iflytek.voicedemo.TtsDemo"
            android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|fontScale"
            android:screenOrientation="portrait" >

    256 layout 优化

        尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点，但往往RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局。

        将可复用的组件抽取出来并通过include标签使用；
            You can also override all the layout parameters (any android:layout_* attributes) of the included layout's root view by specifying them in the <include/>

        使用ViewStub标签来加载一些不常用的布局；

        使用merge标签减少布局的嵌套层次； merge 无属性


    257 LayoutInflater.inflate()

        方法1.LayoutInflater.inflate(layoutId, null)
        方法2.LayoutInflater.inflate(layoutId,parent,false)
        之间的区别为
            方法2,会将parent的LayoutParams设到inflate到的view上，而方法1的LayoutParams是null，因此在adapter的getView 或newView中最好使用方法2


    258 Runtime.exec(cmd) demo

        ///system/bin/sh -c /system/bin/lsof|/system/bin/grep /mnt/hd/sdcard
        String cmd = "/system/bin/lsof|/system/bin/grep /mnt/hd/sdcard";
        try {
            Process process = Runtime.getRuntime().exec(new String[]{"/system/bin/sh","-c",cmd});
            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line = null;
            String result = "";
            while ((line = br.readLine()) != null) {
                result = result + line;
            }
            int programResult = process.waitFor();
            br.close();
            VideoUtils.debug(1, TAG, "result "+programResult+" out : " + result);
        } catch (IOException e) {
            VideoUtils.debug(1, TAG, " : lsof e =======" + e.getMessage());
        } catch (Exception e) {
            // TODO: handle exception
        }



    259   如果你想通过Service把home到后台的Activity启动到前台来，你有两种办法：

    1)、startActivity(i)的方法

    Intent i = new Intent(mActivity,MyActivity.class);i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(i);

    2)、moveTaskToFront的方法：

    ActivityManager am = (ActivityManager) getSystemService(Activity.ACTIVITY_SERVICE);am.moveTaskToFront(mActivity.getTaskId(), 0);

    但同时有两个问题：

    1)、第一种方法：等几秒钟Activity才显示出来

    2)、第二种方法：根本不起左右

    这是你需要在AndroidManifest.xml中添加"android.permission.STOP_APP_SWITCHES"用户权限，前提是必须是系统应用才可以.

    原因是，android系统设计如此，避免后台启动activity影响用户的前台操作，android推荐的做法是通过Notification提示用户，通过用户自己点击显示activity！

    260 adb no permissions

    sudo cp 70-android.rules /etc/udev/rules.d/
    sudo chmod a+x /etc/udev/rules.d/70-android.rules

    sudo /etc/init.d/udev restart

    最后再重启下adb服务，就可以了(没配置环境变量的请进入Android SDK tools目录执行sudo ./adb kill-server ./adb devices)

    sudo adb kill-server
    sudo adb devices

    
    261
        WindowManager.addView() 收不到key事件，flag添加FLAG_NOT_TOUCH_MODAL


    262 android部分说明
    1) android 默认log等级是 DEBUG, 可以通过设置persist.log.tag这个prop来调整
    adb shell setprop persist.log.tag V //设置debug的等级为VERBOSE

    2) 部分系统log是通过Log.isLoggable(TAG, level)来判断是否有log输出，如果是这样的可以通过设置属性来打开log；
    比如AudioService中 DEBUG_VOLUE是如下定义的
    public static final String TAG= AuidoService;
    public static final boolean DEBUG_VOL = Log.isLoggable(TAG + ".VOL", Log.DEBUG) || LOGD;
    那么设置下面属性
    adb shell setprop log.tag.AudioService.VOL D //就可以打开DEBUG_VOL的log




monkeyTest
adb shell monkey -p com.android.contacts -v -v -v 20000\


adb shell am instrument -e class com.android.mms.tests.ConversationListTest -w com.android.mms.test/android.tests.InstrumentationTestRunner

adb shell am instrument -e class com.android.mms.tests.ComposeMessageActivityTest -w com.android.mms.test/android.tests.InstrumentationTestRunner

adb shell am instrument -e class com.android.mms.tests.ConversationListTest1 -w com.android.mms.tests/android.test.InstrumentationTestRunner

adb shell am instrument -w com.android.mms.tests/android.test.InstrumentationTestRunner



adb shell am instrument -w com.archermind.globaltime.test/android.test.InstrumentationTestRunner


mount -o remount,rw /dev/block/mmcblk0p2 /system

adb shell am start -n com.android.settings/.SecuritySettings
adb shell am start -n com.android.settings/.UsbSettings

Adb shell am instrument
-e class com.jayway.test.NotePadTest#testAddNote
-w com.jayway.test /android.test.InstrumentationTestRunner
-e size large(medium,small)
-e perf true -e debug true

robotium
(1) button或view onclick失效,
	在测试程序的manifest.xml中添加,<supports-screens android:anyDensity="true"/>

(2)测试程序读写sdcard
	测试用例的manifest中添加读写sdcard权限
	<uses-permission android:name="android.permission.WRITE_EXTRRNAL_SORAGE"/>
	<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
